<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Distance Estimator Compendium (DEC)</title>

<style>
body {
	font-family: 'Rokkitt', serif;
	color:#481203;
    background-color: #f7f0de;
    margin: 50px 50px 50px 100px;
    line-height: 15px;
}
a:link,
a:visited {
 color:blue;
 text-decoration:none;
 transition:.85s ease-out
}
a:hover {
 color:#FF1203;
 text-decoration:none;
 transition:0s
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
  text-align: Left;
  padding: 4px;
}

td.fitwidth {
    width: 1px;
    white-space: nowrap;
}

td.fitwidth:hover img {
	height:480px;
}

</style>

<style>
@import url('https://fonts.googleapis.com/css2?family=Rokkitt:wght@600&display=swap');
</style>
<link rel = "icon" href = "https://jbaker.graphics/resources/icon.png" type = "image/x-icon">
</head>
<body>

<h1 style='display:inline-block'>Jon Baker, Graphics Programming</h1>
<p style='display:inline-block'> &nbsp; &nbsp; <a href='../index.html'>home</a></p>
<p style='display:inline-block'> &nbsp; &nbsp; <a href='index.html'>writings</a></p>

<div style='width:768px;'>

<h2>The Distance Estimator Compendium (DEC)</h2>


<a href="#introduction" style="font-size:120%;">&nbsp; > Introduction</a><br />
<a href="#simple"       style="font-size:120%;">&nbsp; > Simple Primitives</a><br />
<a href="#operators"    style="font-size:120%;">&nbsp; > Operators</a><br />
<a href="#fractals"     style="font-size:120%;">&nbsp; > Fractals</a><br />
<a href="#composed"     style="font-size:120%;">&nbsp; > Composed Shapes</a><br />
<a href="#licensing"    style="font-size:120%;">&nbsp; > Licensing</a><br />

<a id="introduction"></a><h2>Introduction</h2>
<p>
&nbsp;My goal here is to provide a collected resource of these signed distance functions (SDFs) in a standardized format given by <code>float de( vec3 p ){...}</code>. 
</p>
<p>
&nbsp;SDFs are an interesting method for representing geometry as an implicit functional representation, which produces a result by querying with a given point in space and returning an estimate of the distance to the surface - positive outside, and negative inside. I emphasize that this result is an estimate, especially for some of the fractal SDFs which produce a result by distorting the space in a highly nonlinear fashion.
</p>
<p>
&nbsp;This representation is often used in realtime raymarching, but they come up in applications such as pathtracing and producing of meshes. I have seen several resources on this topic but I hope to gather as much as I can in one place on this page.
</p>

<p>
&nbsp;Mouse over each of the images to view it larger.
</p>


<a id="simple"></a><h2>Simple Primitives</h2>
<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  
  
<tr><td><code>hg_sdf<code></td>    
<td><pre>
Sphere

float de(vec3 p){
  float r = 1; // the radius
  return length(p) - r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/sphere.png" alt="sphere", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Plane

float de(vec3 p){
  vec3 n = vec3(0.,1.,0.);       // plane's normal vector
  float distanceFromOrigin = 0.; // position along normal
  
  return dot(p, n) + distanceFromOrigin;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/plane.png" alt="plane", height=200px></td>
</tr>



<tr><td><code>hg_sdf<code></td>    
<td><pre>
Box

float de(vec3 p){ // cheap version
  vec3 size = vec3(1.); //dimensions on each axis 
  vec3 d = abs(p) - size;

  return max(max(d.x, d.y), d.z);
}

float de(vec3 p){
  vec3 size = vec3(1.) // dimensions on each axis
  vec3 d = abs(p) - size;
  float md = min(d, vec3(0));
  
  return length(max(d, vec3(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/box.png" alt="box", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
2d Infinite Box

float de(vec3 p){  // cheap version
  vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)
  vec2 bd = vec2(1.) // the dimensions of the box
  vec2 d = abs(p0) - bd;
  
  return max(d.x, d.y);
}

float de(vec3 p){
  vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)
  vec2 bd = vec2(1.) // the dimensions of the box
  vec2 d = abs(p0) - bd;
  vec2 md = min(d, vec2(0.));
  
  return length(max(d, vec2(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/box2d.png" alt="box", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Endless Corner/Shelf

float de(vec3 p){
  vec2 p0 = p.xy; // the plane the section lies in
  vec2 md = min(p, vec2(0));

  return length(max(p0, vec2(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/corner.png" alt="corner", height=200px></td>
</tr>

<tr><td><code>tholzer<code></td>    
<td><pre>
Infinite cross shape

float de(vec3 p){
  float s = 0.2; // size of the cross members
  float da = max (abs(p.x), abs(p.y));
  float db = max (abs(p.y), abs(p.z));
  float dc = max (abs(p.z), abs(p.x));
  return min(da,min(db,dc)) - s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cross.png" alt="infinite cross", height=200px></td>
</tr>



<tr><td><code>hg_sdf<code></td>    
<td><pre>
Blob - not a correct distance bound, has artifacts

float de(vec3 p) {
  p = abs(p);
  if (p.x < max(p.y, p.z)) p = p.yzx;
  if (p.x < max(p.y, p.z)) p = p.yzx;
  float b = max(max(max(
    dot(p, normalize(vec3(1, 1, 1))),
    dot(p.xz, normalize(vec2(PHI+1, 1)))),
    dot(p.yx, normalize(vec2(1, PHI)))),
    dot(p.xz, normalize(vec2(1, PHI))));
  float l = length(p);
  return l - 1.5 - 0.2 * (1.5 / 2)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/blob.png" alt="blob", height=200px></td>
</tr>

<tr><td><code>iq<code></td>    
<td><pre>
Infinite Cylinder - perpendicular to xz plane

float de(vec3 p){
  float radius = 1.;
  return length(p.xz)-radius; // xy, yz for other directions
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/infinitecylinder.png" alt="infinite cylinder", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Cylinder in the XZ plane

float de(vec3 p){
  float r = 1.;
  float height = 1.;
  
  float d = length(p.xz) - r;
  d = max(d, abs(p.y) - height);
  
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cylinder.png" alt="cylinder", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Cylinder with rounded edges, also in XZ plane

float de( vec3 p){
  float ra = 0.5;  // radius of cylinder
  float rb = 0.1;  // radius of rounding
  float h  = 0.4;  // height of cylinder

  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/roundcylinder.png" alt="rounded cylinder", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Capsule - cylinder with round caps

float de(vec3 p)
  float r = 1.; // radius
  float c = 1.; // length
  return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));
}

Alternate method

float de_line_segment(vec3 p, vec3 a, vec3 b) {
  vec3 ab = b - a;
  float t = clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.);
  
  return length((ab*t + a) - p);
}

float de(vec3 p){
  vec3 a = vec3(0., -1., 0.); // location of top
  vec3 b = vec3(0.,  1., 0.); // location of bottom
  float r = 1.; // radius

  return de_line_segment(p, a, b) - r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/capsule.png" alt="capsule", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Torus

float de(vec3 p){
  float smallRadius = 1.; // minor radius
  float largeRadius = 2.; // major radius

  return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

Alternate method using circular line SDF - subtract minor radius from result

float de(vec3 p){
  float r = 1.; // major radius
  float l = length(p.xz) - r;
  
  return length(vec2(p.y, l));
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/torus.png" alt="torus", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
2D Disc - no thickness - subtract some amount from result to make a rounded disk

float de(vec3 p){
  float r = 1.; // radius of the circle
  float l = length(p.xz) - r;
  
  return length(vec2(p.y, l));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/disk.png" alt="disk", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Hexagonal Prism

Circumcircle Variant

float de(vec3 p){
  float width = 1.;
  float height = 1.;
  
  return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - width);
}

Incircle Variant

float de(vec3 p){
  float width = 1.;
  float height = 1.;
  vec3 q = abs(p);

  return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - (width*sqrt(3)*0.5));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/hexagon.png" alt="hexagon", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Cone - pointing up the y axis

float de(vec3 p){
  float radius = 1.;
  float height = 3.;
  vec2 q = vec2(length(p.xz), p.y);
  vec2 tip = q - vec2(0, height);
  vec2 mantleDir = normalize(vec2(height, radius));
  float mantle = dot(tip, mantleDir);
  float d = max(mantle, -q.y);
  float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));

  // distance to tip
  if ((q.y > height) && (projected < 0)) {
    d = max(d, length(tip));
  }

  // distance to base ring
  if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
    d = max(d, length(q - vec2(radius, 0)));
  }
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cone.png" alt="cone", height=200px></td>
</tr>


<tr><td><code>Akleman and Chen via hg_sdf<code></td>    
<td><pre>
Generalized Distance Functions - Support for the following Polyhedra

const vec3 GDFVectors[19] = vec3[](
  normalize(vec3(1, 0, 0)),
  normalize(vec3(0, 1, 0)),
  normalize(vec3(0, 0, 1)),

  normalize(vec3(1, 1, 1 )),
  normalize(vec3(-1, 1, 1)),
  normalize(vec3(1, -1, 1)),
  normalize(vec3(1, 1, -1)),

  normalize(vec3(0, 1, PHI+1)),
  normalize(vec3(0, -1, PHI+1)),
  normalize(vec3(PHI+1, 0, 1)),
  normalize(vec3(-PHI-1, 0, 1)),
  normalize(vec3(1, PHI+1, 0)),
  normalize(vec3(-1, PHI+1, 0)),

  normalize(vec3(0, PHI, 1)),
  normalize(vec3(0, -PHI, 1)),
  normalize(vec3(1, 0, PHI)),
  normalize(vec3(-1, 0, PHI)),
  normalize(vec3(PHI, 1, 0)),
  normalize(vec3(-PHI, 1, 0))
);

// Version with variable exponent.
// This is slow and does not produce correct distances, but allows for bulging of objects.
float fGDF(vec3 p, float r, float e, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d += pow(abs(dot(p, GDFVectors[i])), e);
	return pow(d, 1/e) - r;
}

// Version with without exponent, creates objects with sharp edges and flat faces
float fGDF(vec3 p, float r, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d = max(d, abs(dot(p, GDFVectors[i])));
	return d - r;
}
</pre></td>
<td></td>
</tr>


<tr><td></td>    
<td><pre>
Octahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 6);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 6);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/octahedron.png" alt="octahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Dodecahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 13, 18);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 13, 18);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/dodecahedron.png" alt="dodecahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Icosahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 12);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 12);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/icosahedron.png" alt="icosahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Truncated Octahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 0, 6);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 0, 6);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/truncated_octahedron.png" alt="truncated octahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Truncated Icosahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 18);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 18);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/truncated_icosahedron.png" alt="truncated icosahedron", height=200px></td>
</tr>



<tr><td><code>iq<code></td>    
<td><pre>
Octahedron (Alternative)

float de(vec3 p){
  float s = 1.; // size
  p = abs(p);
  float m = p.x+p.y+p.z-s;
  vec3 q;
       if( 3.0*p.x < m ) q = p.xyz;
  else if( 3.0*p.y < m ) q = p.yzx;
  else if( 3.0*p.z < m ) q = p.zxy;
  else return m*0.57735027;
    
  float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
  return length(vec3(q.x,q.y-s+k,q.z-k)); 
}

Approximate (cheaper)

float de( vec3 p){
  float s = 1.;
  p = abs(p);
  return (p.x+p.y+p.z-s)*0.57735027;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/octahedron.png" alt="octahedron", height=200px></td>
</tr>


<tr><td><code>tholzer<code></td>    
<td><pre>
Icosahedron (Alternative)

float de(vec3 p){
  float radius = 1.;
  const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;
  const vec3 n1 = normalize(vec3(q,1,0));
  const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);

  p = abs(p / radius);
  float a = dot(p, n1.xyz);
  float b = dot(p, n1.zxy);
  float c = dot(p, n1.yzx);
  float d = dot(p, n2) - n1.x;
  return max(max(max(a,b),c)-n1.x,d) * radius;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/icosahedron.png" alt="icosahedron", height=200px></td>
</tr>


<tr><td><code>tholzer<code></td>    
<td><pre>
Dodecahedron (Alternative)

float de(vec3 p){
  float radius = 1.;
  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;
  const vec3 n = normalize(vec3(phi,1,0));

  p = abs(p / radius);
  float a = dot(p, n.xyz);
  float b = dot(p, n.zxy);
  float c = dot(p, n.yzx);
  return (max(max(a,b),c)-n.x) * radius;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/dodecahedron.png" alt="dodecahedron", height=200px></td>
</tr>



<tr><td><code>TLC123<code></td>    
<td><pre>
ChamferBox - generalizes sphere, cuboid, and octahedron

float sdOctahedron( in vec3 p, in float s)// by Iq 2019{
    p = abs(p);
    float m = p.x+p.y+p.z-s;
    vec3 q;
         if( 3.0*p.x < m ) q = p.xyz;
    else if( 3.0*p.y < m ) q = p.yzx;
    else if( 3.0*p.z < m ) q = p.zxy;
    else return m*0.57735027;
    
    float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
    return length(vec3(q.x,q.y-s+k,q.z-k)); 
}

float de(vec3 op){
  vec3 b = vec3(1,2,3); // size
  float ch = 0.25;      // chamfer amount
  float r = 0.05;       // rounding

  vec3 p = abs(op)+vec3(ch)+vec3(r);
  p = max(vec3(0),p-b); 
  float d =fOctahedron(p,ch);
  return d-r ;		
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/chamferbox.png" alt="chamferbox", height=200px></td>
</tr>









<tr><td><code>FabriceNeyret2<code></td>    
<td><pre>
Gyroid - Here constrained to a sphere of radius 4

float de(vec3 p) {
  float scale = 7.;
  float thickness = 0.05;
  float bias = 0.1;

  p *= scale;
  return (abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness)*0.55;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/gyroid.png" alt="gyroid", height=200px></td>
</tr>





<tr><td><code>dr2<code></td>    
<td><pre>
Gyroid Torus

float de(vec3 p){
  float rt = 15.;
  float rg = 4.;
  float ws = 0.3;
  
  p.xz = vec2 (rt * atan (p.z, - p.x), length (p.xz) - rt);
  p.yz = vec2 (rg * atan (p.z, - p.y), length (p.yz) - rg);
  return .6* max(abs(dot(sin(p), cos(p).yzx)) - ws, abs(p.z) - .5*PI);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/gyroid_torus.png" alt="gyroid torus", height=200px></td>
</tr>



<tr><td><code>iq<code></td>    
<td><pre>
Ellipsoid

float de(vec3 p) {
    vec3 r = vec3(0.2, 0.25, 0.05); // the radii on each axis
    float k0 = length(p/r);
    float k1 = length(p/(r*r));
    return k0*(k0-1.0)/k1;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/ellipsoid.png" alt="ellipsoid", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Box Frame

float de( vec3 p){
  float e = 0.05;          // edge thickness
  vec3 b = vec3(.3,.5,.4); // box dimensions
  p = abs(p)-b;
  vec3 q = abs(p+e)-e;

  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/boxframe.png" alt="boxframe", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Capped Cone

At origin
float de(vec3 p){
    float h = 1.; // height
    float r1 = 0.5; // radius at bottom
    float r2 = 0.2; // radius at top
    
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );
    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );
}

Between two points a and b
float de(vec3 p){
    vec3 a = vec3(0,0,0); // point a
    vec3 b = vec3(0,1,0); // point b
    float ra = .5; // radius at a
    float rb = .2; // radius at b
    
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;

    float x = sqrt( papa - paba*paba*baba );

    float cax = max(0.0,x-((paba<0.5)?ra:rb));
    float cay = abs(paba-0.5)-0.5;

    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );

    float cbx = x-ra - f*rba;
    float cby = paba - f;
    
    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;
    
    return s*sqrt( min(cax*cax + cay*cay*baba,
                       cbx*cbx + cby*cby*baba) );
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cappedcone.png" alt="capped cone", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Solid Angle

float de(vec3 p){
  float angle = 1.; // desired cone angle
  float ra = 1.; // radius of the sphere from which it is cut

  vec2 c = vec2(sin(angle),cos(angle));
  vec2 p0 = vec2( length(p.xz), p.y );
  float l = length(p0) - ra;
  float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );
  return max(l,m*sign(c.y*p0.x-c.x*p0.y));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/solidangle.png" alt="solid angle", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Capped Torus

float de(vec3 p){
    float angle = 2.0; // angle spanned 
    float ra = 0.25; // major radius
    float rb = 0.05; // minor radius
    
    vec2 sc = vec2(sin(angle), cos(angle));
    p.x = abs(p.x);
    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cappedtorus.png" alt="capped torus", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Square Pyramid

float de(vec3 p){
    float h = 1.; // height 
    float m2 = h*h + 0.25;
    
    // symmetry
    p.xz = abs(p.xz);
    p.xz = (p.z>p.x) ? p.zx : p.xz;
    p.xz -= 0.5;

    // project into face plane (2D)
    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);
   
    float s = max(-q.x,0.0);
    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );
    
    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;
    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);
    
    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);
    
    // recover 3D and scale, and add sign
    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/pyramid.png" alt="pyramid", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Equilateral Triangular Prism

float de(vec3 p){
    vec2 h = vec2(0.5, 0.2); // height, thickness
    const float k = sqrt(3.0);
    h.x *= 0.5*k;
    p.xy /= h.x;
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;
    p.x -= clamp( p.x, -2.0, 0.0 );
    float d1 = length(p.xy)*sign(-p.y)*h.x;
    float d2 = abs(p.z)-h.y;
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/triprism.png" alt="triprism", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Rhomboid Prism

float de(vec3 p){
  float la = 0.15; // first axis
  float lb = 0.25; // second axis
  float h  = 0.04; // thickness
  float ra = 0.08; // corner radius

  p = abs(p);
  vec2 b = vec2(la,lb);
  vec2 bb = b-2.0*p.xz;

  float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );
  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);
  return min(max(q.x,q.y),0.0) + length(max(q,0.0));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/rhombus.png" alt="rhombus", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Rounded Cone - two spheres with convex connection

Located at origin
float de(vec3 p){
  float r1 = 1.0;
  float r2 = 0.1;
  float h = 3.; // height
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

Between two points
float de(vec3 p){
    vec3 a = vec3(0,0,0);
    vec3 b = vec3(0,3,0);
    float r1 = 1.0; // radius at b
    float r2 = 0.1; // radius at a
    
    vec3  ba = b - a;
    float l2 = dot(ba,ba);
    float rr = r1 - r2;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    vec3 pa = p - a;
    float y = dot(pa,ba);
    float z = y - l2;
    vec3 d2 =  pa*l2 - ba*y;
    float x2 = dot(d2, d2);
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    float k = sign(rr)*rr*rr*x2;
    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;
    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;
                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/roundcone.png" alt="round cone", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Octagonal Prism

float de(vec3 p){
  float r = 2.;   // diameter
  float h = 0.2;  // thickness

  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 
                       0.3826834323,   // sqrt(2-sqrt(2))/2
                       0.4142135623 ); // sqrt(2)-1 
  // reflections
  p = abs(p);
  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);
  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);
  // polygon side
  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/octagon.png" alt="octagonal prism", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Link - elongated torus

float de(vec3 p){
    float le = 0.13;  // length
    float r1 = 0.20;  // major radius
    float r2 = 0.09;  // minor radius
    
    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );
    return length(vec2(length(q.xy)-r1,q.z)) - r2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/link.png" alt="link", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Rounded box - unsigned

float de(vec3 p){
    vec3 b = vec3(1,2,3); // box dimensions
    float r = 0.1;      // rounding radius
    return length(max(abs(p)-b, 0.0))-r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/roundbox.png" alt="round box", height=200px></td>
</tr>




<tr><td><code>tholzer<code></td>    
<td><pre>
Wavy sphere 

float de(vec3 p){
    float radius = .3;    // radius of sphere
    int waves = 7;        // number of waves
    float waveSize = 0.4; // displacement of waves
    
    //bounding Sphere
    float d = length(p) - radius*2.2;
    if(d > 0.0) return 0.2;

    // deformation of radius
    d = waveSize * (radius*radius-(p.y*p.y));
    radius += d * cos(atan(p.x,p.z) * float(waves));
    return 0.5*(length(p) - radius);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/wavesphere.png" alt="wave sphere", height=200px></td>
</tr>











<tr><td><code>iq<code></td>    
<td><pre>
Torus8-2 using iq's change of distance metric (see operator section)

float de( vec3 p){
  vec2 t = vec2(1,0.2); // major and minor
  vec2 q = vec2(length2(p.xz)-t.x, p.y);
  return length8(q) - t.y;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/torus82.png" alt="torus 8-2", height=200px></td>
</tr>



<tr><td><code>iq<code></td>    
<td><pre>
Torus8-8 using iq's change of distance metric

float de( vec3 p){
  vec2 t = vec2(1,0.2); // major and minor
  vec2 q = vec2(length2(p.xz)-t.x, p.y);
  return length8(q) - t.y;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/torus88.png" alt="torus 8-8", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Cylinder6 using iq's change of distance metric

float de(vec3 p){
  float diameter = 0.2;
  float height = 0.1;
  return max( length6(p.xz) - diameter, abs(p.y) - height );
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cylinder6.png" alt="cylinder6", height=200px></td>
</tr>


<tr><td><code>iq<code></td>    
<td><pre>
Cylinder8 using iq's change of distance metric

float de(vec3 p){
  float diameter = 0.2;
  float height = 0.1;
  return max( length8(p.xz) - diameter, abs(p.y) - height );
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cylinder8.png" alt="cylinder8", height=200px></td>
</tr>



<tr><td><code>iq<code></td>    
<td><pre>
Unsigned distance to triangle

float dot2( in vec3 v ) { return dot(v,v); }
float de( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )
{
    // prepare data    
    vec3 v21 = v2 - v1; vec3 p1 = p - v1;
    vec3 v32 = v3 - v2; vec3 p2 = p - v2;
    vec3 v13 = v1 - v3; vec3 p3 = p - v3;
    vec3 nor = cross( v21, v13 );

    return sqrt( // inside/outside test    
                 (sign(dot(cross(v21,nor),p1)) + 
                  sign(dot(cross(v32,nor),p2)) + 
                  sign(dot(cross(v13,nor),p3))<2.0) 
                  ?
                  // 3 edges    
                  min( min( 
                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), 
                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), 
                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )
                  :
                  // 1 face    
                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/triangle.png" alt="triangle", height=200px></td>
</tr>

<tr><td><code>iq<code></td>    
<td><pre>
Unsigned distance to quad

float dot2( in vec3 v ) { return dot(v,v); }
float udQuad( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 p )
{
    // handle ill formed quads
    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )
    {
        vec3 tmp = v3;
        v3 = v4;
        v4 = tmp;
    }
   
    vec3 v21 = v2 - v1; vec3 p1 = p - v1;
    vec3 v32 = v3 - v2; vec3 p2 = p - v2;
    vec3 v43 = v4 - v3; vec3 p3 = p - v3;
    vec3 v14 = v1 - v4; vec3 p4 = p - v4;
    vec3 nor = cross( v21, v14 );

    return sqrt( (sign(dot(cross(v21,nor),p1)) + 
                  sign(dot(cross(v32,nor),p2)) + 
                  sign(dot(cross(v43,nor),p3)) + 
                  sign(dot(cross(v14,nor),p4))<3.0) 
                  ?
                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), 
                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), 
                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),
                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))
                  :
                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/quad.png" alt="quad", height=200px></td>
</tr>








</table>
<br>


<a id="operators"></a><h2>Operators</h2>
<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>



<tr><td><code>WIP<code></td>    
<td><pre>
WIP
</pre></td>
<td class="fitwidth"><img src="images/DEC/WIP.png" alt="WIP", height=200px></td>
</tr>




</table>
<br>




<a id="fractals"></a><h2>Fractals</h2>
<p>&nbsp; These are very concise expressions of complex geometry, with operations condensed to their simplest expressions. Many of these have been deobfuscated from minimized #つぶやきGLSL examples. The forms are highly complex and often use magic numbers to control geometry - these provide opportunities to manipulate the forms, and may provide insight for those with the motivation to in dig into it. </p>

<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  
  
  
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    p.xyz = mod(p.xyz-1.,2.)-1.;
    p*=1.4/dot(p.xyz,p.xyz);
  }
  return (length(p.xz/p.w)*0.25);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de.png" alt="fractal_de", height=200px></td>
</tr>
  
  <!-- fractal_de2 looks like shit -->
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=(1.2/dot(p.xyz,p.xyz));
  }
  p/=p.w;
  return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de3.png" alt="fractal_de3", height=200px></td>
</tr>
  
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    p = abs(p);
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=1.23;
  }
  p/=p.w;
  return abs(p.y)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de4.png" alt="fractal_de4", height=200px></td>
</tr>
  
  

<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 pos ) 
{
#define SCALE 2.8
#define MINRAD2 .25
#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)
  float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);
  float absScalem1 = abs(SCALE - 1.0);
  float AbsScale = pow(abs(SCALE), float(1-10));
  vec4 p = vec4(pos,1);
  vec4 p0 = p;
  for (int i = 0; i < 9; i++)
  {
    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    float r2 = dot(p.xyz, p.xyz);
    p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
    p = p*scale + p0;
  }
  return ((length(p.xyz) - absScalem1) / p.w - AbsScale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de5.png" alt="fractal_de5", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){ 
  p = p.xzy;
  vec3 cSize = vec3(1., 1., 1.3);
  float scale = 1.;
  for( int i=0; i < 12; i++ ){
    p = 2.0*clamp(p, -cSize, cSize) - p;
    float r2 = dot(p,p);
    float k = max((2.)/(r2), .027);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 4.0;
  float n = l * p.z;
  rxy = max(rxy, -(n) / 4.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de6.png" alt="fractal_de6", height=200px></td>
</tr>
  





<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  p = p.xzy;
  vec3 cSize = vec3(1., 1., 1.3);
  float scale = 1.;
  for( int i=0; i < 12;i++ ){
    p = 2.0*clamp(p, -cSize, cSize) - p;
    float r2 = dot(p,p+sin(p.z*.3));
    float k = max((2.)/(r2), .027);
    p *= k;  scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 4.0;
  float n = l * p.z;
  rxy = max(rxy, -(n) / 4.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de7.png" alt="fractal_de7", height=200px></td>
</tr>




<tr><td><code>iq<code></td>    
<td><pre>
float de( vec3 p ){
  float scale = 1.0;
  float orb = 10000.0;
  for( int i=0; i<6; i++ ){
    p = -1.0 + 2.0*fract(0.5*p+0.5);
    p -= sign(p)*0.04; // trick
    float r2 = dot(p,p);
    float k = 0.95/r2;
    p  *= k;  scale *= k;
    orb = min( orb, r2);
  }

  float d1 = sqrt( min( min( dot(p.xy,p.xy), 
    dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;
  float d2 = abs(p.y);
  float dmi = d2;
  if( d1 < d2 ) dmi = d1;
  return 0.5*dmi/scale;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de8.png" alt="fractal_de8", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  vec3 CSize = vec3(1., 1.7, 1.);
  p = p.xzy;
  float scale = 1.1;
  for( int i=0; i < 8;i++ ){
    p = 2.0*clamp(p, -CSize, CSize) - p;
    float r2 = dot(p,p);
    float k = max((2.)/(r2), .5);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 1.0;
  float n = l * p.z;
  rxy = max(rxy, (n) / 8.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de9.png" alt="fractal_de9", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  vec3 CSize = vec3(1., 1.7, 1.);
  p = p.xzy;
  float scale = 1.1;
  for( int i=0; i < 8;i++ ){
    p = 2.0*clamp(p, -CSize, CSize) - p;
    float r2 = dot(p,p+sin(p.z*.3));
    float k = max((2.)/(r2), .5);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 1.0;
  float n = l * p.z;
  rxy = max(rxy, (n) / 8.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de10.png" alt="fractal_de10", height=200px></td>
</tr>

  <!-- fractal_de11 looks like shit -->

<tr><td><code>unknown<code></td>    
<td><pre>
vec3 fold( vec3 p0 ){
  vec3 p = p0;
  if(length(p) > 1.2) return p;
  p = mod(p,2.)-1.;
  return p;
}

float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 12; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    p = abs(p);
    p.xyz = fold(p.xyz);
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=(1.2/dot(p.xyz,p.xyz));
  }
  p/=p.w;
  return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de12.png" alt="fractal_de12", height=200px></td>
</tr>


  <!-- fractal_de13 looks like shit -->
  <!-- fractal_de14 looks like shit -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
float de( vec3 p ){
  p=abs(p)-1.2;
  if(p.x < p.z)p.xz=p.zx;
  if(p.y < p.z)p.yz=p.zy;
  if(p.x < p.y)p.xy=p.yx;
  float s=1.;
  for(int i=0;i<6;i++){
    p=abs(p);
    float r=2./clamp(dot(p,p),.1,1.);
    s*=r; p*=r; p-=vec3(.6,.6,3.5);
  }
  float a=1.5;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de15.png" alt="fractal_de15", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
float de( vec3 p ){
    // box fold
    p=abs(p)-15.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=2.;
    for (int i=0; i<8; i++){
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        float r=-1.55/max(.41,dot(p,p));
        s*=r; p*=r; p-=.5;
    }
    s=abs(s);
    return dot(p,normalize(vec3(1,2,3)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de16.png" alt="fractal_de16", height=200px></td>
</tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
void sFold90( inout vec2 p ){
    vec2 v=normalize(vec2(1,-1));
    float g=dot(p,v);
    p-=(g-sqrt(g*g+1e-1))*v;
}

float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-1.8;
    sFold90(p.zy);
    sFold90(p.xy);
    sFold90(p.zx);
    float s=2.;
    vec3  offset=p*.5;
    for(int i=0;i<8;i++){
        p=1.-abs(p-1.);
        float r=-1.3*max(1.5/dot(p,p),1.5);
        s*=r; p*=r; p+=offset;
        p.zx*=rot(-1.2);
    }
    s=abs(s); float a=8.5;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de17.png" alt="fractal_de17", height=200px></td>
</tr>
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm( vec3 p, float n ){
    p = pow(abs(p), vec3(n));
    return pow(p.x+p.y+p.z, 1.0/n);
}

float de( vec3 p ){
  vec3 offset=p*.5;
  float s=2.;
  for (int i=0; i<5; i++){
    p=clamp(p,-1.,1.)*2.-p;
    float r=-10.*clamp(max(.3/pow(
    lpNorm(p,5.),2.),.3),.0,.6);
    s*=r; p*=r; p+=offset;
  }
  s=abs(s); float a=10.;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de18.png" alt="fractal_de18", height=200px></td>
</tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define sabs1(p)sqrt((p)*(p)+1e-1)
#define sabs2(p)sqrt((p)*(p)+1e-3)
float de( vec3 p ){
  float s=2.; p=abs(p);
  for (int i=0; i<4; i++){
    p=1.-sabs2(p-1.);
    float r=-9.*clamp(max(.2/pow(min(min(sabs1(p.x),
      sabs1(p.y)),sabs1(p.z)),.5), .1), 0., .5);
    s*=r; p*=r; p+=1.;
  }
  s=abs(s); float a=2.;
  p-=clamp(p,-a,a);
  return length(p)/s-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de19.png" alt="fractal_de19", height=200px></td>
</tr>
  
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=3.;
    for(int i = 0; i < 4; i++) {
        p=mod(p-1.,2.)-1.;
        float r=1.2/dot(p,p);
        p*=r; s*=r;
    }
    p = abs(p)-0.8;
    if (p.x < p.z) p.xz = p.zx;
    if (p.y < p.z) p.yz = p.zy;
    if (p.x < p.y) p.xy = p.yx;
    return length(cross(p,normalize(vec3(0,1,1))))/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de20.png" alt="fractal_de20", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=3.; p=abs(p);
    for (float i=0.; i<9.; i++){
        p-=clamp(p,-1.,1.)*2.;
        float r=6.62*clamp(.12/min(dot(p,p),1.),0.,1.);
        s*=r; p*=r; p+=1.5;
    }
    s=abs(s); float a=.8;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de21.png" alt="fractal_de21", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=12.; p=abs(p);
    vec3 offset=p*3.;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-5.5*clamp(.3*max(2.5/dot(p,p),.8),0.,1.5);
        p*=r; p+=offset; s*=r;
    }
    s=abs(s); p=abs(p)-3.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float a=3.;
    p-=clamp(p,-a,a);
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de22.png" alt="fractal_de22", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-3.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=3.;
    vec3  offset=p*1.2;
    for (float i=0.;i<8.;i++){
        p=1.-abs(p-1.);
        float r=-6.5*clamp(.41*max(1.1/dot(p,p),.8),.0,1.8);
        s*=r; p*=r; p+=offset;
        p.yz*=rot(-1.2);
    }
    s=abs(s);
    float a=20.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de23.png" alt="fractal_de23", height=200px></td>
</tr>






<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-2.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=2.5;
    vec3 off=p*2.8;
    for (float i=0.;i<6.;i++) {
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        float r=-11.*clamp(.8*max(2.5/dot(p,p),.2),.3,.6);
        s*=r; p*=r; p+=off;
        p.yz*=rot(2.1);
    }
    s=abs(s);
    float a=30.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de24.png" alt="fractal_de24", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    p=abs(p);
    float s=3.;
    vec3  offset = p*.5;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-3.*clamp(.57*max(3./dot(p,p),.9),0.,1.);
        s*=r; p*=r; p+=offset;
    }
    s=abs(s);
    return length(cross(p,normalize(vec3(1))))/s-.008;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de25.png" alt="fractal_de25", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    p.xy=abs(p.xy)-2.;
    if(p.x < p.y)p.xy=p.yx;
    p.z=mod(p.z,4.)-2.;
    p.x-=3.2; p=abs(p);
    float s=2.;
    vec3 offset= p*1.5;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-7.5*clamp(.38*max(1.2/dot(p,p),1.),0.,1.);
        s*=r; p*=r; p+=offset;
    }
    s=abs(s);
    float a=100.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de26.png" alt="fractal_de26", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  float s=1.;
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy=abs(p.xy)-.2;
    p.xy*=rot(.3);
    p.yz*=rot(.3);
    p*=2.; s*=2.;
  }
  p/=s;
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de27.png" alt="fractal_de27", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=1.;
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy-=.2; p*=2.; s*=2.;
  }
  p/=s;
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de28.png" alt="fractal_de28", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy-=.2; p.xy*=rot(.5); p.yz*=rot(.5);
  }
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de29.png" alt="fractal_de29", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define TAUg atan(1.)*8.
vec2 pmodg(vec2 p, float n){
  float a=mod(atan(p.y, p.x),TAUg/n)-.5 *TAUg/n;
  return length(p)*vec2(sin(a),cos(a));
}

float de( vec3 p ){
    for(int i=0;i<4;i++){
        p.xy = pmodg(p.xy,10.);  p.y-=2.;
        p.yz = pmodg(p.yz, 12.); p.z-=10.;
    }
    return dot(abs(p),normalize(vec3(13,1,7)))-.7;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de30.png" alt="fractal_de30", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.x-=4.;
  p=mod(p,8.)-4.;
  for(int j=0;j<3;j++){
     p.xy=abs(p.xy)-.3;
     p.yz=abs(p.yz)+.7,
     p.xz=abs(p.xz)-.2;
  }
  return length(cross(p,vec3(.5)))-.1;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de31.png" alt="fractal_de31", height=200px></td>
</tr>


  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 fold(vec3 p0){
    vec3 p = p0;
    if(length(p) > 2.)return p;
    p = mod(p,2.)-1.;
    return p;
}

float de( vec3 p0 ){
    vec4 p = vec4(p0, 1.);
    escape = 0.;
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p = abs(p);
    for(int i = 0; i < 8; i++){
        p.xyz = fold(p.xyz);
        p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;
        p*=(1.1/clamp(dot(p.xyz,p.xyz),-0.1,1.));
    }
    p/=p.w;
    return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de32.png" alt="fractal_de32", height=200px></td>
</tr>


    <!-- fractal_de33 crashes -->    
    <!-- fractal_de34 crashes -->
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
    p=mod(p,2.)-1.;
    p=abs(p)-1.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=1.;
    for(int i=0;i<10;i++){
      float r2=2./clamp(dot(p,p),.1,1.);
      p=abs(p)*r2-vec3(.6,.6,3.5);
      s*=r2;
    }
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de35.png" alt="fractal_de35", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
	float itr=10.,r=0.1;
	p=mod(p-1.5,3.)-1.5;
	p=abs(p)-1.3;
	if(p.x < p.z)p.xz=p.zx;
	if(p.y < p.z)p.yz=p.zy;
 	if(p.x < p.y)p.xy=p.yx;
	float s=1.;
	p-=vec3(.5,-.3,1.5);
	for(float i=0.;i++ < itr;) {
		float r2=2./clamp(dot(p,p),.1,1.);
		p=abs(p)*r2;
		p-=vec3(.7,.3,5.5);
		s*=r2;
	}
   return length(p.xy)/(s-r);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de36.png" alt="fractal_de36", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++) {
    p=1.-abs(p-1.);
    r2=1.2/dot(p,p); 
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.003;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de37.png" alt="fractal_de37", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++) {
    p=1.-abs(p-1.);
    r2=(i%3==1)?1.3:1.3/dot(p,p);
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.003;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de38.png" alt="fractal_de38", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define fold45(p)(p.y>p.x)?p.yx:p
float de(vec3 p) {
  float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
  vec3 off =vec3(2.,.2,.1);
  float s=1.0;
  for(int i = 0;++i<20;) { 
    p.xy = abs(p.xy);
    p.xy = fold45(p.xy);
    p.y -= off0;
    p.y = -abs(p.y);
    p.y += off0;
    p.x += off1;
    p.xz = fold45(p.xz);
    p.x -= off2;
    p.xz = fold45(p.xz);
    p.x += off1;
    p -= off;
    p *= scale;
    p += off;
    s *= scale;
  }
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de40.png" alt="fractal_de40", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=4.;
  p=abs(p);
  vec3 off=p*4.6;
  for (float i=0.; i<8.; i++){
    p=1.-abs(abs(p-2.)-1.); 
    float r=-13.*clamp(.38*max(1.3/dot(p,p),.7),0.,3.3);
    s*=r; p*=r; p+=off;
  }
  return length(cross(p,normalize(vec3(1,3,3))))/s-.006;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de41.png" alt="fractal_de41", height=200px></td>
</tr>


   <!-- fractal_de42 crashes -->
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 rotate(vec3 p,vec3 axis,float theta){
  vec3 v = cross(axis,p), u = cross(v, axis);
  return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   
}

vec2 pmod(vec2 p, float r){
  float a = mod(atan(p.y, p.x), (M_PI*2) / r) - 0.5 * (M_PI*2) / r;
  return length(p) * vec2(-sin(a), cos(a));
}

float de(vec3 p){
  for(int i=0;i<5;i++){
    p.xy = pmod43(p.xy,12.0); p.y-=4.0;
    p.yz = pmod43(p.yz,16.0); p.z-=6.8;
  }
  return dot(abs(p),rotate43(normalize(vec3(2,1,3)),
      normalize(vec3(7,1,2)),1.8))-0.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de43.png" alt="fractal_de43", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define pmod(p,n)length(p)*sin(vec2(0.,M_PI/2.)\
 +mod(atan(p.y,p.x),2.*M_PI/n)-M_PI/n)
#define fold(p,v)p-2.*min(0.,dot(p,v))*v;

float de( vec3 p ){
  float s = 1.0;
  p.z=fract(p.z)-.5;
  for(int i=0;i<20;i++){ // expensive
    p.y += .15;
    p.xz = abs(p.xz);
    for(int j=0;j<2;j++){
      p.xy = pmod(p.xy,8.);
      p.y -= .18;
    }
    p.xy = fold(p.xy,normalize(vec2(1,-.8)));
    p.y = -abs(p.y);
    p.y += .4;
    p.yz = fold(p.yz,normalize(vec2(3,-1)));
    p.x -= .47;
    p.yz = fold(p.yz,normalize(vec2(2,-7)));
    p -= vec3(1.7,.4,0);
    float r2= 3.58/dot(p,p);
    p *= r2;
    p += vec3(1.8,.7,.0);
    s *= r2;
  }
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de44.png" alt="fractal_de44", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.z-=2.5;
  float s = 3.;
  float e = 0.;
  for(int j=0;j++<8;)
    s*=e=3.8/clamp(dot(p,p),0.,2.),
    p=abs(p)*e-vec3(1,15,1);
  return length(cross(p,vec3(1,1,-1)*.577))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de45.png" alt="fractal_de45", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s = 2.;
  float e = 0.;
  for(int j=0;++j<7;)
    p.xz=abs(p.xz)-2.3,
    p.z>p.x?p=p.zyx:p,
    p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),
    p.y>p.x?p=p.yxz:p,
    p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),
    p.y>p.x?p=p.yxz:p,
    p.y=.9-abs(p.y-.4),
    e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+
    2.*clamp(.1/min(dot(p,p),1.),.0,1.),
    p=e*p-vec3(7,1,1),
    s*=e;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de46.png" alt="fractal_de46", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s = 4.;
  for(int i = 0; i < 8; i++) {
    p=mod(p-1.,2.)-1.;
    float r2=(i%3==0)?1.5:1.2/dot(p,p);
    p*=r2; s*=r2;
  }
  vec3 q=p/s;
  q.xz=mod(q.xz-.002,.004)-.002;
  return min(length(q.yx)-.0003,length(q.yz)-.0003);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de47.png" alt="fractal_de47", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.z-=-1.;
#define fold(p,v)p-2.*min(0.,dot(p,v))*v;
  float s=3., l=0.;
  for(int i = 0;++i<15;){
    p.xy=fold(p.xy,normalize(vec2(1,-1.3)));
    p.y=-abs(p.y);
    p.y+=.5;
    p.xz=abs(p.xz);
    p.yz=fold(p.yz,normalize(vec2(8,-1)));
    p.x-=.5;
    p.yz=fold(p.yz,normalize(vec2(1,-2)));
    p-=vec3(1.8,.4,.1);
    l = 2.6/dot(p,p);    p*=l;
    p+=vec3(1.8,.7,.2);  s*=l;
  }
  return length(p.xy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de48.png" alt="fractal_de48", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm(vec3 p, float n){
  p = pow(abs(p), vec3(n));
  return pow(p.x+p.y+p.z, 1.0/n);
}

float de(vec3 p){
  float s = 1.;
  for(int i = 0; i < 9; i++) {
    p=p-2.*round(p/2.);
    float r2=1.1/max(pow(lpNorm(p.xyz, 4.5),1.6),.15);
    p*=r2; s*=r2;
  }
  return length(p)/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de49.png" alt="fractal_de49", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float hash(float x){
  return fract(sin(x*234.123+156.2));
}
float lpNorm(vec3 p, float n){
  p = pow(abs(p), vec3(n));
  return pow(p.x+p.y+p.z, 1.0/n);
}
float de(vec3 p){
  vec2 id=floor(p.xz);
  p.xz=mod(p.xz,1.)-.5;
  p.y=abs(p.y)-.5;
  p.y=abs(p.y)-.5;
  p.xy*=rot(hash(dot(id,vec2(12.3,46.7))));
  p.yz*=rot(hash(dot(id,vec2(32.9,76.2))));
  float s = 1.;
  for(int i = 0; i < 6; i++) {
    float r2=1.2/pow(lpNorm(p.xyz, 5.0),1.5);
    p-=.1; p*=r2; s*=r2; p=p-2.*round(p/2.);
  }
  return .6*dot(abs(p),normalize(vec3(1,2,3)))/s-.002;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de50.png" alt="fractal_de50", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  for(int j=0;++j<8;)
    p.z-=.3,
    p.xz=abs(p.xz),
    p.xz=(p.z>p.x)?p.zx:p.xz,
    p.xy=(p.y>p.x)?p.yx:p.xy,
    p.z=1.-abs(p.z-1.),
    p=p*3.-vec3(10,4,2);

  return length(p)/6e3-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de51.png" alt="fractal_de51", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm(vec3 p, float n){
  p = pow(abs(p),vec3(n));
  return pow(p.x+p.y+p.z,1./n);
}
float de( vec3 p ){
  float scale=4.5;
  float mr2=.5;
  float off=.5;
  float s=1.;
  vec3 p0 = p;
  for (int i=0; i<16; i++) {
    if(i%3==0)p=p.yzx;
    if(i%2==1)p=p.yxz;
    p -= clamp(p,-1.,1.)*2.;
    float r2=pow(lpNorm(p.xyz,5.),2.);
    float g=clamp(mr2*max(1./r2,1.),0.,1.);
    p=p*scale*g+p0*off;
    s=s*scale*g+off;
  }
  return length(p)/s-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de52.png" alt="fractal_de52", height=200px></td>
</tr>

  <!-- fractal_de53 crashes -->
  <!-- fractal_de54 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  float s=2.;
  float e=0.;
  vec3 q=vec3(3,3,.0);
  for(int i=0; i++<7; p=q-abs(p-q*.4))
    s*=e=15./min(dot(p,p),15.),
    p=abs(p)*e-2.;
  return (length(p.xz)-.5)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de55.png" alt="fractal_de55", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  vec3 q;
  p-=vec3(1.,.1,.1);
  q=p;
  float s=1.5;
  float e=0.;
  for(int j=0;j++<15;s*=e)
    p=sign(p)*(1.2-abs(p-1.2)),
    p=p*(e=8./clamp(dot(p,p),.3,5.5))+q*2.;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de56.png" alt="fractal_de56", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  p.xz=fract(p.xz)-.5;
  float k=1.;
  float s=0.;
  for(int i=0;i++<9;)
    s=2./clamp(dot(p,p),.1,1.),
    p=abs(p)*s-vec3(.5,3,.5),
    k*=s;
  return length(p)/k-.001;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de57.png" alt="fractal_de57", height=200px></td>
</tr>

  <!-- fractal_de58 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  p.xz=fract(p.xz)-.5;
  float k=1.;
  float s=0.;
  for(int i=0;i++<9;)
    s=2./clamp(dot(p,p),.1,1.),
    p=abs(p)*s-vec3(.5,3,.5),
    k*=s;
  return length(p)/k-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de59.png" alt="fractal_de59", height=200px></td>
</tr>





<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float de(vec3 p){
  p=abs(p)-3.;
  if(p.x < p.z)p.xz=p.zx;
  if(p.y < p.z)p.yz=p.zy;
  if(p.x < p.y)p.xy=p.yx;
  float s=2.; vec3 off=p*.5;
  for(int i=0;i<12;i++){
    p=1.-abs(p-1.);
    float k=-1.1*max(1.5/dot(p,p),1.5);
    s*=abs(k); p*=k; p+=off;
    p.zx*=rot(-1.2);
  }
  float a=2.5;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de61.png" alt="fractal_de61", height=200px></td>
</tr>

  <!-- fractal_de63 crashes -->

<tr><td><code>xem<code></td>    
<td><pre> 
float de(vec3 p){
  vec4 o=vec4(p,1);
  vec4 q=o;
  for(float i=0.;i<9.;i++){
    o.xyz=clamp(o.xyz,-1.,1.)*2.-o.xyz;
    o=o*clamp(max(.25/dot(o.xyz,o.xyz),.25),0.,1.)*vec4(11.2)+q;
  }
  return (length(o.xyz)-1.)/o.w-5e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de66.png" alt="fractal_de66", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  float g=1.;
  float e=0.;
  vec3 q=vec3(0);
  p.z-=1.;
  q=p;
  float s=2.;
  for(int j=0;j++<8;)
    p-=clamp(p,-.9,.9)*2.,
    p=p*(e=3./min(dot(p,p),1.))+q,
    s*=e;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de72.png" alt="fractal_de72", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  vec3 q;
  p.z-=1.5;
  q=p;
  float e=0.;
  float s=3.;
  for(int j=0;j++<8;s*=e)
    p=sign(p)*(1.-abs(abs(p-2.)-1.)),
    p=p*(e=6./clamp(dot(p,p),.3,3.))+q-vec3(8,.2,8);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de75.png" alt="fractal_de75", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
    vec3 q;
    p.z-=1.5;
    q=p;
    float e=0.;
    float s=3.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.-abs(abs(p-2.)-1.)),
        p=p*(e=6./clamp(dot(p,p),.3,3.))+q-vec3(8,.2,8);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de76.png" alt="fractal_de76", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.;
    float l=dot(p,p);
    float e=0.;
    escape=0.;
    p=abs(abs(p)-.7)-.5;
    p.x < p.y?p=p.yxz:p;
    p.y < p.z?p=p.xzy:p;
    for(int i=0;i++<8;){
        s*=e=2./clamp(dot(p,p),.004+tan(12.)*.002,1.35);
        p=abs(p)*e-vec2(.5*l,12.).xxy;
    }
    return length(p-clamp(p,-1.,1.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de78.png" alt="fractal_de78", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=1.5;
    vec3 q=p;
    float s=1.5;
    float e=0.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.2-abs(p-1.2)),
        p=p*(e=8./clamp(dot(p,p),.6,5.5))+q-vec3(.3,8,.3);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de79.png" alt="fractal_de79", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float e=1.,B=2.95,H=.9, s=2.;
    p.z=mod(p.z-2.,4.)-2.;
    for(int j=0;j++<8;)
    {
        p=abs(p);
        p.x < p.z?p=p.zyx:p;
        p.x=H-abs(p.x-H);
        p.y < p.z?p=p.xzy:p;
        p.xz+=.1;
        p.y < p.x?p=p.yxz:p;
        p.y-=.1;
    }
    p*=B; p-=2.5; s*=B;
    return length(p.xy)/s-.007;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de80.png" alt="fractal_de80", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define hash(n) fract(sin(n*234.567+123.34))
  float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   
  p-=clamp(p,-3.5,3.5)*2.;
  float scale=-5.;
  float mr2=.38;
  float off=1.2;
  float s=3.;
  p=abs(p);
  vec3  p0 = p;
  for (float i=0.; i<4.+hash(seed)*6.; i++){
    p=1.-abs(p-1.);
    float g=clamp(mr2*max(1.2/dot(p,p),1.),0.,1.);
    p=p*scale*g+p0*off;
    s=s*abs(scale)*g+off;
  }
  return length(cross(p,normalize(vec3(1))))/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de81.png" alt="fractal_de81", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define hash(n) fract(sin(n*234.567+123.34))
  float zoom=2.1;
  p*=zoom;
  float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   
  p-=clamp(p,-8.,8.)*2.;
  float s=3.*zoom;
  p=abs(p);
  vec3  p0 = p*1.6;
  for (float i=0.; i<10.; i++){
    p=1.-abs(abs(p-2.)-1.); 
    float g=-8.*clamp(.43*max(1.2/dot(p,p),.8),0.,1.3);
    s*=abs(g); p*=g; p+=p0;
  }
  return length(cross(p,normalize(vec3(1))))/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de82.png" alt="fractal_de82", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=16.; float s=3.; float e=0.;
    p.y=abs(p.y)-1.8;
    p=clamp(p,-3.,3.)*2.-p;
    s*=e=6./clamp(dot(p,p),1.5,50.);
    p=abs(p)*e-vec3(0,1.8,0);
    p.xz =.8-abs(p.xz-2.);
    p.y =1.7-abs(p.y-2.);
    s*=e=12./clamp(dot(p,p),1.0,50.);
    p=abs(p)*e-vec2(.2,1).xyx;
    p.y =1.5-abs(p.y-2.);
    s*=e=16./clamp(dot(p,p),.1,9.);
    p=abs(p)*e-vec2(.3,-.7).xyx;
    return min(
            length(p.xz)-.5,
            length(vec2(length(p.xz)-12.,p.y))-3.
            )/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de84.png" alt="fractal_de84", height=200px></td>
</tr>



<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
  vec4 p = vec4(p0/10., 1.);
  escape = 0.; p=abs(p);
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p*=(1.3/clamp(dot(p.xyz,p.xyz),0.1,1.));
    p.xyz-=vec3(.5,0.2,0.2);
  }
  float m = 1.5;
  p.xyz-=clamp(p.xyz,-m,m);
  return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de86.png" alt="fractal_de86", height=200px></td>
</tr>


<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
    vec4 p = vec4(p0/10., 1.);
    escape = 0.; p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 6; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p = abs(p);
        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.1,1.));
        p.xyz-=vec3(0.2,1.9,0.6);
    }
    float m = 1.2;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de87.png" alt="fractal_de87", height=200px></td>
</tr>



<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
    vec4 p = vec4(p0/10., 1.);
    escape = 0.; p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 6; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p = abs(p);
        p*=(2./clamp(dot(p.xyz,p.xyz),0.1,1.));
        p.xyz-=vec3(0.9,1.9,0.9);
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de88.png" alt="fractal_de88", height=200px></td>
</tr>


<tr><td><code>Ivan Dianov<code></td>
<td><pre> 
float de(vec3 p){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  p.z-=.25;
  float j=0.,c=0.,s=1.;
  p.y = fract(p.y)-.5;
  for(;j<10.;j++){
    p=abs(p);
    p-=vec2(.05,.5).xyx;
    p.xz*=rot(1.6);
    p.yx*=rot(.24);
    p*=2.; s*=2.;
  }
  return (length(p)-1.)/s*.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de89.png" alt="fractal_de89", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  float j = 0.5;
  for(p.xz=mod(p.xz,6.)-3.;++j<9.;p=3.*p-.9)
    p.xz=abs(p.xz),
    p.z>p.x?p=p.zyx:p,
    p.y>p.z?p=p.xzy:p,
    p.z--,
    p.x-=++p.y*.5;
  return min(.2,p.x/4e3-.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de90.png" alt="fractal_de90", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=4.;
  float l=0;
  p.z-=.9;
  vec3 q=p;
  s=2.;
  for(int j=0;j++<9;)
    p-=clamp(p,-1.,1.)*2.,
    p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,
    s*=l;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de91.png" alt="fractal_de91", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=3., l=0.;
  vec3 q=p;
  p=mod(p,4.)-2.;
  p=abs(p);
  for(int j=0;j++<8;)
    p=1.-abs(p-1.),
    p=p*(l=-1.*max(1./dot(p,p),1.))+.5,
    s*=l;
  return max(.2-length(q.xy),length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de92.png" alt="fractal_de92", height=200px></td>
</tr>


<tr><td><code>eiffie<code></td>
<td><pre> 
float de(vec3 p){
  const int iters=5;
  const int iter2=3;
  const float scale=3.48;
  const vec3 offset=vec3(1.9,0.0,2.56);
  const float psni=pow(scale,-float(iters));
  const float psni2=pow(scale,-float(iter2));
  p = abs(mod(p+3., 12.)-6.)-3.;
  vec3 p2;
  for (int n = 0; n < iters; n++) {
    if(n==iter2)p2=p;
    p = abs(p);
    if (p.x < p.y)p.xy = p.yx;
    p.xz = p.zx;
    p = p*scale - offset*(scale-1.0);
    if(p.z<-0.5*offset.z*(scale-1.0))
    p.z+=offset.z*(scale-1.0);
  }
  float d1=(length(p.xy)-1.0)*psni;
  float d2=length(max(abs(p2)-vec3(0.2,5.1,1.3),0.0))*psni2;
  escape=(d1 < d2)?0.:1.;
  return min(d1,d2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de93.png" alt="fractal_de93", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  p=fract(p)-.5;
  vec3 O=vec3(2.,0,3.);
  for(int j=0;j++<7;){
    p=abs(p);
    p=(p.x < p.y?p.zxy:p.zyx)*3.-O;
    if(p.z < -.5*O.z)
    p.z+=O.z;
  } 
  return length(p.xy)/3e3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de94.png" alt="fractal_de94", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  p=fract(p)-.5;
  vec3 O=vec3(2.,0,5.);
  for(int j=0;j++<7;){
    p=abs(p);
    p=(p.x < p.y?p.zxy:p.zyx)*3.-O;
    if(p.z < -.5*O.z)
    p.z+=O.z;
  } 
  return length(p.xy)/3e3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de95.png" alt="fractal_de95", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.; p = abs(p);
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de96.png" alt="fractal_de96", height=200px></td>
</tr>



<tr><td><code>variant of code by gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.;
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de97.png" alt="fractal_de97", height=200px></td>
</tr>



<tr><td><code>variant of code by gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.;
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de98.png" alt="fractal_de98", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float i,g,e=1.,s=2.,l;
  vec3 a=vec3(.5);
  p.z-=55.; p=abs(p);
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-1.55/max(.4,dot(p,p)),
    p=p*l-.535;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de99.png" alt="fractal_de99", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;vec3 q;
    q=p*2.;
    R=7.;
    for(int j=0;j++<9;){
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        S=-9.*clamp(.7/min(dot(p,p),3.),0.,1.);
        p=p*S+q; R=R*abs(S);
    }
    return length(p)/R; 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de100.png" alt="fractal_de100", height=200px></td>
</tr>





<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
void rot101(inout vec3 p,vec3 a,float t){
	a=normalize(a);
	vec3 u=cross(a,p),v=cross(a,u);
	p=u*sin(t)+v*cos(t)+a*dot(a,p);   
}
#define G dot(p,vec2(1,-1)*.707)
#define V v=vec2(1,-1)*.707
void sfold101(inout vec2 p){
    vec2 v=vec2(1,-1)*.707;
    float g=dot(p,v);
    p-=(G-sqrt(G*G+.01))*v;
}
float de(vec3 p){
    float k=.01;
    for(int i=0;i<8;i++){
        p=abs(p)-1.;
        sfold101(p.xz);
        sfold101(p.yz);
        sfold101(p.xy);
        rot101(p,vec3(1,2,2),.6);
        p*=2.;
    }
    return length(p.xy)/exp2(8.)-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de101.png" alt="fractal_de101", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    #define V vec2(.7,-.7)
    #define G(p)dot(p,V)
    float i=0.,g=0.,e=1.;
    float t = 0.34; // change to see different behavior
    for(int j=0;j++<8;){
        p=abs(rotate3D(0.34,vec3(1,-3,5))*p*2.)-1.,
        p.xz-=(G(p.xz)-sqrt(G(p.xz)*G(p.xz)+.05))*V;
    }
    return length(p.xz)/3e2;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de102.png" alt="fractal_de102", height=200px></td>
</tr>




<tr><td><code>Kali<code></td>
<td><pre> 
float de(vec3 p) {
  const float width=.22;
  const float scale=4.;
  float t=0.2;
  float dotp=dot(p,p);
  p.x+=sin(t*40.)*.007;
  p=p/dotp*scale;
  p=sin(p+vec3(sin(1.+t)*2.,-t,-t*2.));
  float d=length(p.yz)-width;
  d=min(d,length(p.xz)-width);
  d=min(d,length(p.xy)-width);
  d=min(d,length(p*p*p)-width*.3);
  return d*dotp/scale;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de103.png" alt="fractal_de103", height=200px></td>
</tr>

<!-- fractal_de104 crashes -->
<!-- fractal_de105 isn't a valid distance bound -->

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,a,n,h,d=1.,t=0.3; // change t for different behavior
    vec3 q;
    n=.4;
    for(a=1.;a<2e2;n+=q.x*q.y*q.z/a)
        p.xy*=rotate2D(a+=a),
        q=cos(p*a+t);
    return n*.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de106.png" alt="fractal_de106", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    vec3 z,q;
    p.z -= 9.; z=p;
    float a=1.,n=.9;
    for(int j=0;j++<15;){
        p.xy*=rotate2D(float(j*j));
        a*=.66;
        q=sin(p*=1.5);
        n+=q.x*q.y*q.z*a;
    }
    return (n*.2-z.z*.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de107.png" alt="fractal_de107", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
      vec3 q;
      float s=1., a=1., n=.5;
      for(int j=0;j++<9;){
          p.xy*=rotate2D(float(j*j));
          a*=.5; q=sin(p+=p);
          n+=q.x*q.y*q.z*a;
      }
      return n*.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de108.png" alt="fractal_de108", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float h,d=1.,i,u,s, t = 0.8; // vary t for different behavior
    p+=vec3(1,1,sin(t/4.)*3.);
    s=2.;
    for(int j=0;j<9;j++){
        p.xy*=rotate2D(t/4.);
        u=4./3./dot(p,p);
        s*=u;
        p=mod(1.-p*u,2.)-1.;
    }
    return (length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de109.png" alt="fractal_de109", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,d=1.,s,h;
    vec3 e,q;
    s=2.;h=.3;
    for(int j=0;j++<8;){
        p=abs(p)-1.; q=p;
        for(int k=0;++k<3;)
            p-=clamp(dot(q,e=vec3(9>>k&1,k>>1&1,k&1)-.5),-h,h)*e*2.;
        p*=1.4;s*=1.4;
    }
    return length(p)/(4.*s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de110.png" alt="fractal_de110", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float  de(vec3 p){
    float i,g,e=1.,s,l;
    p.z-=9.; s=2.;
    p=abs(p);
    for(int j=0;j++<6;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-2./max(.3,sqrt(min(min(p.x,p.y),p.z))),
        p-=2., s*=l;
    return length(p)/s;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de111.png" alt="fractal_de111", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s;
    vec3 q=p; s=5.;
    for(int j=0;j++<6;s*=e)
        p=sign(p)*(1.7-abs(p-1.7)),
        p=p*(e=8./clamp(dot(p,p),.3,5.))+q-vec3(.8,12,.8);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de112.png" alt="fractal_de112", height=200px></td>
</tr>




<tr><td><code>adapted from code by catzpaw<code></td>
<td><pre> 
float de(vec3 p){
    float k = M_PI*2.;
    vec3 v = vec3(0.,3.,fract(k));
    return (length(cross(p=cos(p+v),p.zxy))-0.1)*0.4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de113.png" alt="fractal_de113", height=200px></td>
</tr>




<tr><td><code>adapted from code by catzpaw<code></td>
<td><pre> 
float de(vec3 p){
    float k = M_PI*2.;
    vec3 v = vec3(0.,3.,fract(k));
    return (length(cross(cos(p+v),p.zxy))-0.4)*0.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de114.png" alt="fractal_de114", height=200px></td>
</tr>




<tr><td><code>catzpaw<code></td>
<td><pre> 
float de(vec3 p){  (distance bound doesn't hold)
    vec3 v=vec3(0,1.5,6.3);
    return min(6.-length((p-v).xy+sin(p.yx)), 
      dot(cos(p),sin(p.yzx)))+sin(sin(p.z*3.5)+v.z)*.1+1.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de115.png" alt="fractal_de115", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=80.; p=abs(p);
    float s=3., l=0.;
    for(int j=0;j++<8;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-.8/min(2.,length(p)),
        p-=.5, s*=l;
    return (length(p)/s)-0.1;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de116.png" alt="fractal_de116", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s = 1.;
    for(int j=0;j<7;j++)
        p=mod(p-1.,2.)-1.,
        p*=1.2, s*=1.2,
        p=abs(abs(p)-1.)-1.;
    return (length(cross(p,normalize(vec3(2,2.03,1))))/s)-0.02;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de117.png" alt="fractal_de117", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., l=0.;
    p=abs(p);
    for(int j=0;j++<8;)
        p=1.-abs(abs(p-2.)-1.),
        p*=l=1.2/dot(p,p), s*=l;
    return dot(p,normalize(vec3(3,-2,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de118.png" alt="fractal_de118", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., l=0.;
    p=abs(p);
    for(int j=0;j++<8;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-1.3/dot(p,p),
        p-=.15, s*=l;
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de119.png" alt="fractal_de119", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=20;
    float s=3., l=0.;
    p=abs(p);
    for(int j=0;j++<10;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-1./max(.19,dot(p,p)),
        p-=.24, s*=l;
    return (length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de120.png" alt="fractal_de120", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
      float s=2., l=0.;
      p=abs(mod(p-1.,2.)-1.);
      for(int j=0;j++<8;)
          p=1.-abs(abs(abs(p-5.)-2.)-2.),
          p*=l=-1.3/dot(p,p),
          p-=vec3(.3,.3,.4), s*=l;
      return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de121.png" alt="fractal_de121", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e=1.,R,S;
    vec3 q=p*8.; R=8.;
    for(int j=0;j++<6;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        S=-5.*clamp(1.5/dot(p,p),.8,5.),
        p=p*S+q, R*=S;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de122.png" alt="fractal_de122", height=200px></td>
</tr>

<!-- fractal_de123 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre>
float de(vec3 p){
    float i,g,e,s=2.,k;
    vec3 q;
    p=vec3(length(p.xy)-PI,atan(p.y,p.x)*PI,p.z);
    p.yz=mod(p.yz,4.)-2.;
    p=abs(p); q=p;
    for(int j=0;++j<5;)
        p=1.-abs(p-1.),
        p=-p*(k=max(3./dot(p,p),3.))+q, s*=k;
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de124.png" alt="fractal_de124", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R=2.,S;
    for(int j=0;j++<9;)
        p=1.-abs(p-1.),
        p*=S=(j%3>1)?1.3:1.2/dot(p,p),
        R*=S;
    return length(cross(p,vec3(.5)))/R-5e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de125.png" alt="fractal_de125", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++){
    p=1.-abs(p-1.);
    r2=(i%3==1)?1.1:1.2/dot(p,p);
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de126.png" alt="fractal_de126", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=3.,l;
    vec3 q=p;
    for(int j=0;j++<9;)
        p=mod(p-1.,2.)-1.,
        l=1.2/pow(pow(dot(pow(abs(p),vec3(5)),vec3(1)),.2),1.6),
        p*=l, s*=l;
    return abs(p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de127.png" alt="fractal_de127", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=4.,l;
    vec3 q=p;
    for(int j=0;j++<9;)
        p=mod(p-1.,2.)-1.,
        l=1.2/dot(p,p),
        p*=l, s*=l;
    return abs(p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de128.png" alt="fractal_de128", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=1.,l;
    vec3 q=p;
    for(int j=0;j++<4;)
        p=mod(p-1.,2.)-1.,
        l=2./dot(p,p),
        p*=l, s*=l;
    return length(p.xy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de129.png" alt="fractal_de129", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define F1(s)p.s=abs(p.s)-1.
    p+=vec3(0,3.8,5.);
    vec3 q=p;
    p=mod(p,vec3(8,8,2))-vec3(4,4,1);
    F1(yx); F1(yx); F1(xz);
    return min(length(cross(p,vec3(.5)))-.03,length(p.xy)-.05);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de130.png" alt="fractal_de130", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float l,s=3.;
    float t = 4.5;
    for(int j=0;j++<5;p.xy=fract(p.xy+p.x)-.5)
        p=vec3(log(l=length(p.xy)),atan(p.y,p.x)/PI*2.,p.z/l+1.),
        s*=.5*l;
    return abs(p.z)*s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de131.png" alt="fractal_de131", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q=p; R=2.;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=9.*clamp(.7/min(dot(p,p),3.),0.,1.),
        p=p*S+q,
        R=R*abs(S)+1.,
        p=p.yzx;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de133.png" alt="fractal_de133", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R=1.,S;
    vec3 q=p;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=6.*clamp(.2/min(dot(p,p),7.),0.,1.),
        p=p*S+q*.7,  R=R*abs(S)+.7;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de134.png" alt="fractal_de134", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q;
    p.z-=3.;
    q=p; R=1.;
    for(int j=0;j++<9;)
        p-=clamp(p,-.9,.9)*2.,
        S=9.*clamp(.1/min(dot(p,p),1.),0.,1.),
        p=p*S+q, R=R*S+1.;
    return .7*length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de135.png" alt="fractal_de135", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q;
    p.z-=4.;
    q=p; R=1.;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=9.*clamp(.3/min(dot(p,p),1.),0.,1.),
        p=p*S+q*.5,
        R=R*abs(S)+.5;
    return .6*length(p)/R-1e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de136.png" alt="fractal_de136", height=200px></td>
</tr>


<tr><td><code>takusakuw<code></td>
<td><pre> 
float de(vec3 p){
    return length(sin(p)+cos(p*.5))-.4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de137.png" alt="fractal_de137", height=200px></td>
</tr>


<tr><td><code>yosshin<code></td>
<td><pre> 
float de(vec3 p){
    return min(.65-length(fract(p+.5)-.5),p.y+.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de138.png" alt="fractal_de138", height=200px></td>
</tr>


<tr><td><code>takusakuw<code></td>
<td><pre> 
float de(vec3 p){
    return (length(sin(p.zxy)-cos(p.zzx))-.5);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de139.png" alt="fractal_de139", height=200px></td>
</tr>


<tr><td><code>yuruyurau<code></td>
<td><pre> 
float de(vec3 p){
#define b(p)length(max(abs(mod(p,.8)-.4)-.05,0.))
    vec3 l;
    p=cos(p)-vec3(.3), p.yx*=mat2(cos(.8+vec4(0,3,5,0)));
    return min(min(b(p.xy),b(p.xz)),b(p.yz));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de140.png" alt="fractal_de140", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    #define F1(a,n)a=abs(a)-n,a=vec2(a.x*.5+a.y,a.x-a.y*.5)
    p=fract(p)-.5;
    for(int j=0;j++<8;)
      F1(p.zy,.0),
      F1(p.xz,.55);
    return .4*length(p.yz)-2e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de141.png" alt="fractal_de141", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define M(a)mat2(cos(a+vec4(0,2,5,0)))
#define F1(a)for(int j=0;j<5;j++)p.a=abs(p.a*M(3.));(p.a).y-=3.
    float t = 0.96;
    p.z-=9.;
    p.xz*=M(t);
    F1(xy);
    F1(zy);
    return dot(abs(p),vec3(.3))-.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de142.png" alt="fractal_de142", height=200px></td>
</tr>


<tr><td><code>adapted from code by alia<code></td>
<td><pre> 
float de(vec3 p){
    vec3 q=fract(p)-.5;
    float f=-length(p.xy)+2., g=length(q)-.6;
    return max(f,-g);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de143.png" alt="fractal_de143", height=200px></td>
</tr>


<tr><td><code> adapted from code by wrighter - aliasing issues<code></td>
<td><pre> 
float de(vec3 p){
   vec3 a = sin(p/dot(p,p)*4);
   return 0.95*min(length(a.yx),length(a.yz))-0.52+0.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de144.png" alt="fractal_de144", height=200px></td>
</tr>


<tr><td><code>phi16<code></td>
<td><pre> 
float de(vec3 p){ 
    return length(.05*cos(9.*p.y*p.x)+cos(p)-.1*cos(9.*(p.z+.3*p.x-p.y)))-1.; 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de145.png" alt="fractal_de145", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    vec3 q=p;
    float s=5., e=0.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.-abs(abs(p-2.)-1.)),
        p=p*(e=6./clamp(dot(p,p),.1,3.))-q*vec3(2,8,5);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de146.png" alt="fractal_de146", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float e=2., s=0., z=0.;
    for(int j=0;++j<6;p=abs(p)-1.5,e/=s=min(dot(p,p),.75),p/=s);
    z+=length(p.xz)/e;
    return z;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de147.png" alt="fractal_de147", height=200px></td>
</tr>

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,j,e,g,h,s;
    p.y-=p.z*.5;
    for(j=s=h=.01;j++<9.;s+=s)
        p.xz*=rotate2D(2.),
        h+=abs(sin(p.x*s)*sin(p.z*s))/s;
    return max(0.,p.y+h);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de148.png" alt="fractal_de148", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s,q;
    q=length(p)-1.;
    p.y++;
    s=3.;
    for(int i=0;i++<7;p=vec3(0,5,0)-abs(abs(p)*e-3.))
        s*=e=max(1.,14./dot(p,p));
    return max(q,min(1.,length(p.xz)-.3))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de149.png" alt="fractal_de149", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e=0.;
    for(int i=0;i++<8;p=abs(p)*e)
        p=vec3(.8,2,1)-abs(p-vec3(1,2,1)),
        s*=e=1.3/clamp(dot(p,p),.1,1.2);
    return min(length(p.xz),p.y)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de150.png" alt="fractal_de150", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g=.3,e,s=2.,q;
    for(int i=0;i++<7;p=vec3(2,5,1)-abs(abs(abs(p)*e-3.)-vec3(2,5,1)))
        s*=e=12./min(dot(p,p),12.);
    return min(1.,length(p.xz)-.2)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de151.png" alt="fractal_de151", height=200px></td>
</tr>


<tr><td><code>kamoshika<code></td>
<td><pre> 
float de(vec3 p){
    vec3 Q;
    float i,d=1.,a,b=sqrt(3.);
    Q=mod(p,b*2.)-b;
    a=1.; d=9.;
    for(int j=0;j++<7;){
        Q=abs(Q);
        d=min(d,(dot(Q,vec3(1)/b)-1.)/a);
        Q=Q*3.-6./b;a*=3.;
    }
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de152.png" alt="fractal_de152", height=200px></td>
</tr>


<tr><td><code>kamoshika<code></td>
<td><pre> 
float de(vec3 p){
    float i,d=1.,b=1.73;
    vec3 Q=mod(p,b*2.)-b;
    for(int j=0;j++<6;){
        Q=abs(Q);
        if(Q.y>Q.x)Q.xy=Q.yx;
        if(Q.z>Q.x)Q.zx=Q.xz;
        Q*=2.;
        Q.x-=b;
    }
    return (dot(abs(Q),vec3(1)/b)-1.)/64.;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de153.png" alt="fractal_de153", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
  return (length(vec2((length(vec2(length(p.xy)-1.3,
    length(p.zy)-1.3))-.5), dot(cos(p*12.),sin(p.zxy*12.))*.1))-.02)*.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de154.png" alt="fractal_de154", height=200px></td>
</tr>


<!-- fractal_de155 crashes -->



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
      p.yz*=rotate2D(-.3);
      float ss=3., s=1.;
      for(int j=0; j++<7;){
          p=abs(p); p.y-=.5;
          s = 1./clamp(dot(p,p),.0,1.);
          p*=s; ss*=s;
          p-=vec2(1,.1).xxy;
          p.xyz=p.zxy;
      }
      return length(p.xy)/ss-.01;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de156.png" alt="fractal_de156", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.yz*=rotate2D(-.3);
    float ss=3., s=1.;
    for(int j=0; j++<7;){
        p=abs(p); p.y-=.5;
        s = 1./clamp(dot(p,p),.0,1.);
        p*=s; ss*=s;
        p-=vec2(1,.1).xxy;
        p.xyz=p.zxy;
    }
    return length(max(abs(p)-.6,0.))/ss-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de157.png" alt="fractal_de157", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<8;){
        p=.1-abs(p-.2);
        p.x < p.z?p=p.zyx:p;
        s*=e=1.6;
        p=abs(p)*e-vec3(.1,3,1);
        p.yz*=rotate2D(.8);
    }
    return length(p.yx)/s-.04;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de158.png" alt="fractal_de158", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<8;){
        p=.5-abs(p);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=1.6;
        p=abs(p)*e-vec3(.5,30,5);
        p.yz*=rotate2D(.3);
    }
    return length(p.xy)/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de159.png" alt="fractal_de159", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3.,e;
    for(int i=0;i++<3;p=vec3(2,4,2)-abs(abs(p)*e-vec3(3,6,1)))
        s*=e=1./min(dot(p,p),.6);
    return min(length(p.xz),abs(p.y))/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de160.png" alt="fractal_de160", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    s*=e=3./min(dot(p,p),50.);
    p=abs(p)*e;
    for(int i=0;i++<5;)
        p=vec3(2,4,2)-abs(p-vec3(4,4,2)),
            s*=e=8./min(dot(p,p),9.),
            p=abs(p)*e;
    return min(length(p.xz)-.1,p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de161.png" alt="fractal_de161", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., offset=8., e;
    for(int i=0;i++<9;p=vec3(2,4,2)-abs(abs(p)*e-vec3(4,4,2)))
        s*=e=max(1.,(8.+offset)/dot(p,p));
    return min(length(p.xz),p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de162.png" alt="fractal_de162", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=sin(2.8*p+5.*sin(p*.3));
    float s=2., e;
    for(int i=0;i++<6;)
        p=abs(p-1.7)-1.5,
        s*=e=2.3/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e;
    return length(p.zy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de163.png" alt="fractal_de163", height=200px></td>
</tr>



<tr><td><code>nameless<code></td>
<td><pre> 
float de(vec3 p0){
    p0=p0/10.;
    p0 = mod(p0, 2.)-1.;
    vec4 p = vec4(p0, 1.);
    p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 8; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p.xyz = abs(p.xyz);
        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.6,1.));
        p.xyz-=vec3(0.7,1.8,0.5);
        p*=1.2;
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de164.png" alt="fractal_de164", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=5., e;
    p=p/dot(p,p)+1.;
    for(int i=0;i++<8;p*=e)
        p=1.-abs(p-1.),
        s*=e=1.6/min(dot(p,p),1.5);
    return length(cross(p,normalize(vec3(1))))/s-5e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de165.png" alt="fractal_de165", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e, offset = 1.; //offset can be adjusted 
    for(int i=0;i++<8;p*=e)
        p=abs(p-vec3(1,3,1.5+offset*.3))-vec3(1,3.+offset*.3,2),
        p*=-1., s*=e=7./clamp(dot(p,p),.7,7.);
    return (p.z)/s+1e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de166.png" alt="fractal_de166", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=sin(p+3.*sin(p*.5));
    float s=2., e;
    for(int i=0;i++<5;)
        p=abs(p-1.7)-1.3,
        s*=e=2./min(dot(p,p),1.5),
        p=abs(p)*e-1.;
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de167.png" alt="fractal_de167", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define M(p)p=vec2(sin(atan(p.x,p.y)*4.)/3.,1)*length(p),p.y-=2.
    float i,g,e,s;
    for(s=3.;s<4e4;s*=3.)
        M(p.xy),
        M(p.zy),
        p*=3.;
    return length(p.xy)/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de168.png" alt="fractal_de168", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=1.-abs(abs(p+sin(p))-1.);
    p=p.x < p.y?p.zxy:p.zyx;
    float s=5., l;
    for(int j=0;j++<4;)
        s*=l=2./min(dot(p,p),1.5),
        p=abs(p)*l-vec3(2,1,3);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de169.png" alt="fractal_de169", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    for(int j=0;++j<5;)
        s*=e=1./min(dot(p,p),1.),
        p=abs(p)*e-1.5;
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de170.png" alt="fractal_de170", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.2,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return length(cross(p,vec3(1,1,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de171.png" alt="fractal_de171", height=200px></td>
</tr>

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=mod(p.xz,2.)-1.;
    vec3 q=p;
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.5,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return max(q.y,length(p.xz)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de172.png" alt="fractal_de172", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=abs(p.xz)-1.;
    p.x>p.z?p=p.zyx:p;
    float s=2., e;
    for(int j=0;j++<7;)
        s*=e=2.2/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e-vec3(1,8,.03);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de173.png" alt="fractal_de173", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<7;)
        s*=e=2.2/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e-vec3(1,8,1);
    return length(cross(p,vec3(1,1,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de174.png" alt="fractal_de174", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=mod(p.xz,2.)-1.;
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.5,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de175.png" alt="fractal_de175", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.,e;
    for(int i=0;i<9;i++){
        p=.5-abs(p-.5);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=2.4;
        p=abs(p)*e-vec3(.1,13,5);
    }
    return length(p)/s-0.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de176.png" alt="fractal_de176", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<7;){
        p.xz=.8-abs(p.xz);
        p.x < p.z?p=p.zyx:p;
        s*=e=2.1/min(dot(p,p),1.);
        p=abs(p)*e-vec3(1,18,9);
    }
    return length(p)/s-0.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de177.png" alt="fractal_de177", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float n=1.+snoise3D(p), s=4., e;
    for(int i=0;i++<7;p.y-=20.*n)
        p.xz=.8-abs(p.xz),
        p.x < p.z?p=p.zyx:p,
        s*=e=2.1/min(dot(p,p),1.),
        p=abs(p)*e-n;
    return length(p)/s+1e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de179.png" alt="fractal_de179", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    for(int i=0;i++<8;)
        p=mod(p-1.,2.)-1.,
        s*=e=1.4/dot(p,p),
        p*=e;
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de180.png" alt="fractal_de180", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=4., e;
    for(int i=0;i++<7;p.y-=10.)
        p.xz=.8-abs(p.xz),
        p.x < p.z?p=p.zyx:p,
        s*=e=2.5/clamp(dot(p,p),.1,1.2),
        p=abs(p)*e-1.;
    return length(p)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de181.png" alt="fractal_de181", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<10;){
        p=.3-abs(p-.8);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=1.7;
        p=abs(p)*e-vec3(1,50,5);
    }
    return length(p.xy)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de182.png" alt="fractal_de182", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=1., e, offset=0.26; // vary between 0 and 1
    for(int i=0;i++<5;){
        s*=e=2./min(dot(p,p),1.);
        p=abs(p)*e-vec3(1,10.*offset,1);
    }
    return length(max(abs(p)-1.,0.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de183.png" alt="fractal_de183", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.5, e;
    p=abs(mod(p-1.,2.)-1.)-1.;
    for(int j=0;j++<10;)
        p=1.-abs(p-1.),
        s*=e=-1.8/dot(p,p),
        p=p*e-.7;
    return abs(p.z)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de184.png" alt="fractal_de184", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<8;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de185.png" alt="fractal_de185", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<8;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p-clamp(p,-2.,2.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de186.png" alt="fractal_de186", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<18;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de187.png" alt="fractal_de187", height=200px></td>
</tr>

<tr><td><code>amini<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    s*=e=3./min(dot(p,p),50.);
    p=abs(p)*e;
    for(int i=0;i++<5;)
        p=vec3(8,4,2)-abs(p-vec3(8,4,2)),
        s*=e=8./min(dot(p,p),9.),
        p=abs(p)*e;
    return min(length(p.xz)-.1,p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de188.png" alt="fractal_de188", height=200px></td>
</tr>

<!-- fractal_de190 isn't a valid distance bound -->

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 p){
    p.x = abs(p.x) - 3.3;
    p.z = mod(p.z + 2.0, 4.0) -  2.0;
    vec4 q = vec4(p, 1);
    q.xyz -= 1.0;
    q.xyz = q.zxy;
    for(int i = 0; i < 6; i++) {
        q.xyz = abs(q.xyz + 1.0) - 1.0;
        q /= clamp(dot(q.xyz, q.xyz), 0.25, 1.0);
        q *= 1.1;
        float s = sin(-0.35);
        float c = cos(-0.35);
        q.xy = mat2(c,s,-s,c)*q.xy;
    }
    return (length(q.xyz) - 1.5)/q.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de191.png" alt="fractal_de191", height=200px></td>
</tr>

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=abs(.5-mod(p.xz,1.))+.01;
    float DEfactor=1.;
    for (int i=0; i<14; i++) {
        p = abs(p)-vec3(0.,2.,0.);  
        float r2 = dot(p, p);
        float sc=2./clamp(r2,0.4,1.);
        p*=sc; 
        DEfactor*=sc;
        p = p - vec3(0.5,1.,0.5);
    }
    return length(p)/DEfactor-.0005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de192.png" alt="fractal_de192", height=200px></td>
</tr>

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 pos){
    vec3 tpos=pos;
    tpos.xz=abs(.5-mod(tpos.xz,1.));
    vec4 p=vec4(tpos,1.);
    float y=max(0.,.35-abs(pos.y-3.35))/.35;
    for (int i=0; i<7; i++) {
        p.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);
        p=p*(2.0+0.*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);
        p.xz*=mat2(-0.416,-0.91,0.91,-0.416);
    }
    return (length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de193.png" alt="fractal_de193", height=200px></td>
</tr>

<tr><td><code>shane<code></td>
<td><pre> 
float de(vec3 p){
    const vec3 offs = vec3(1, .75, .5); // Offset point.
    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);
    const mat2 m = mat2(a.y, -a.x, a);
    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);
    const mat2 m2 = mat2(a2.y, -a2.x, a2);
    const float s = 5.; // Scale factor.
    float d = 1e5; // Distance.
    p  = abs(fract(p*.5)*2. - 1.);
    float amp = 1./s;
    for(int i=0; i<2; i++){
        p.xy = m*p.xy;
        p.yz = m2*p.yz;
        p = abs(p);
        p.xy += step(p.x, p.y)*(p.yx - p.xy);
        p.xz += step(p.x, p.z)*(p.zx - p.xz);
        p.yz += step(p.y, p.z)*(p.zy - p.yz);
        p = p*s + offs*(1. - s);
        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);
        p=abs(p);
        d = min(d, max(max(p.x, p.y), p.z)*amp);
        amp /= s;
    }
    return d - .035;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de194.png" alt="fractal_de194", height=200px></td>
</tr>

<tr><td><code>avi<code></td>
<td><pre> 
float de(vec3 p) {
    const vec3 va = vec3(  0.0,  0.57735,  0.0 );
    const vec3 vb = vec3(  0.0, -1.0,  1.15470 );
    const vec3 vc = vec3(  1.0, -1.0, -0.57735 );
    const vec3 vd = vec3( -1.0, -1.0, -0.57735 );
    float a = 0.0;
    float s = 1.0;
    float r = 1.0;
    float dm;
    vec3 v;
    for(int i=0; i<16; i++) {
        float d, t;
        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;
        d = dot(p-vb,p-vb); if( d < dm ) { v=vb; dm=d; t=1.0; }
        d = dot(p-vc,p-vc); if( d < dm ) { v=vc; dm=d; t=2.0; }
        d = dot(p-vd,p-vd); if( d < dm ) { v=vd; dm=d; t=3.0; }
        p = v + 2.0*(p - v); r*= 2.0;
        a = t + 4.0*a; s*= 4.0;
    }
    return (sqrt(dm)-1.0)/r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de195.png" alt="fractal_de195", height=200px></td>
</tr>

<tr><td><code>guil<code></td>
<td><pre> 
vec3 foldY(vec3 P, float c){
  float r = length(P.xz);
  float a = atan(P.z, P.x);
  a = mod(a, 2.0 * c) - c; 
  P.x = r * cos(a);
  P.z = r * sin(a);
  return P;
}

float de(vec3 p){ 
  float l= length(p)-1.;
  float dr = 1.0, g = 1.25;
  vec4 ot=vec4(.3,.5,0.21,1.);
  ot = vec4(1.);
  mat3 tr = rotate3D(-0.55, normalize(vec3(-1., -1., -0.5)));

  for(int i=0;i<15;i++) {
    if(i-(i/3)*5==0)
    p = foldY(p, .95);
    p.yz = abs(p.yz);				
    p = tr * p * g -1.;		
    dr *= g;
    ot=min(ot,vec4(abs(p),dot(p,p)));
    l = min (l ,(length(p)-1.) / dr);
  }
  return l;    
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de196.png" alt="fractal_de196", height=200px></td>
</tr>


<tr><td><code>marvelousbilly<code></td>
<td><pre> 
mat3 rotmat(float angle, vec3 axis){
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;
	return mat3(oc * axis.x * axis.x + c,  oc * axis.x * axis.y - axis.z * s,
	  oc * axis.z * axis.x + axis.y * s,  oc * axis.x * axis.y + axis.z * s,  
	  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 
	  oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  
	  oc * axis.z * axis.z + c);
}
float de(vec3 p){    
    mat3 r = rotmat(3.14159, vec3(0.,1.,0.)); //rotation matrix
    float scale= 2.;
    int Iterations = 10;
    int i;
    vec3 C = vec3(1.,5.4,10.+10.*sin(0.5));
    for(i = 0; i < Iterations; i++){ 
        p = r * (p);
        float x = p.x; float y = p.y; float z = p.z; float x1 = x; float y1 = y;
        x=abs(x);y = abs(y);
        if(x-y<0.){x1=y;y=x;x=x1;}
        if(x-z<0.){x1=z;z=x;x=x1;}
        if(y-z<0.){y1=z;z=y;y=y1;}

        z-=0.5*C.z*(scale-1.)/scale;
        z=-abs(-z);
        z+=0.5*C.z*(scale-1.)/scale;
        
        p = vec3(x,y,z);
        r = rotmat(31.4159/4.+5.60,vec3(1.,0.5,0.6));
        p = r * (p);
        x = p.x; y = p.y; z = p.z;
        
        x=scale*x-C.y*(scale-1.);
        y=scale*y-C.y*(scale-1.);
        z=scale*z;

        p = vec3(x,y,z);
    }
    return (length(p) - 2.) * pow(scale,float(-i)); 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de197.png" alt="fractal_de197", height=200px></td>
</tr>



<tr><td><code>adapted from code by marvelousbilly<code></td>
<td><pre> 
float de(vec3 p){    
    mat3 r = rotate3D(3.14159, vec3(0.,1.,0.));
    float scale= 2.;
    int Iterations = 10;
    int i;
    vec3 C = vec3(1.,5.4,10.+10.*sin(0.5));
    for(i = 0; i < Iterations; i++){ 
        p = r * (p);
        float x = p.x; float y = p.y; float z = p.z; float x1 = x; float y1 = y;

        x=abs(x);y = abs(y);
        if(x-y<0.){x1=y;y=x;x=x1;}
        if(x-z<0.){x1=z;z=x;x=x1;}
        if(y-z<0.){y1=z;z=y;y=y1;}

        z-=0.5*C.z*(scale-1.)/scale;
        z=-abs(-z);
        z+=0.5*C.z*(scale-1.)/scale;
        
        p = vec3(x,y,z);
        r = rotate3D(31.4159/4.+5.60,vec3(1.,0.5,0.6));
        p = r * (p);
        x = p.x; y = p.y; z = p.z;
        
        x=scale*x-C.y*(scale-1.);
        y=scale*y-C.y*(scale-1.);
        z=scale*z;

        p = vec3(x,y,z);
    }
    return (length(p) - 2.) * pow(scale,float(-i)); 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de198.png" alt="fractal_de198", height=200px></td>
</tr>


<tr><td><code>nameless<code></td>
<td><pre> 
float de(vec3 p0){
  vec4 p = vec4(p0, 1.);
  p.xyz=abs(p.xyz);
  if(p.x > p.z)p.xz = p.zx;
  if(p.z < p.y)p.zy = p.yz;
  if(p.y > p.x)p.yx = p.xy;
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p.xyz = abs(p.xyz);
    p*=(2.15/clamp(dot(p.xyz,p.xyz),.4,1.));
    p.xyz-=vec3(0.3,0.2,1.6);
  }
  float m = 1.5;
  p.xyz-=clamp(p.xyz,-m,m);
  return length(p.xyz)/p.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de199.png" alt="fractal_de199", height=200px></td>
</tr>



<tr><td><code>evilryu<code></td>
<td><pre> 
void ry(inout vec3 p, float a){  
    float c,s;vec3 q=p;  
    c = cos(a); s = sin(a);  
    p.x = c * q.x + s * q.z;  
    p.z = -s * q.x + c * q.z; 
}  
float plane(vec3 p, float y) {
    return length(vec3(p.x, y, p.z) - p);
}
float menger_spone(in vec3 z0){
    z0=z0.yzx;
    vec4 z=vec4(z0,1.0);
    vec3 offset =0.83*normalize(vec3(3.4,2., .2));
    float scale = 2.;
    for (int n = 0; n < 8; n++) {
        z = abs(z);
        ry(z.xyz, 1.5);
        if (z.x < z.y)z.xy = z.yx;
        if (z.x < z.z)z.xz = z.zx;
        if (z.y < z.z)z.yz = z.zy;
        ry(z.xyz, -1.21);
        z = z*scale;
        z.xyz -= offset*(scale-1.0);
    }
    return (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.01)/z.w;
}
float de(vec3 p){ 
    float d1 = plane(p, -0.5);
    float d2 = menger_spone(p+vec3(0.,-0.1,0.));
    float d = d1;
    vec3 res = vec3(d1, 0., 0.);
    if(d > d2){
        d = d2;
        res = vec3(d2, 1., 0.0);
    }
    return res.x;
} 
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de200.png" alt="fractal_de200", height=200px></td>
</tr>




<tr><td><code>adapted from code by jorge2017a1<code></td>
<td><pre> 
float de( vec3 p ){
    vec3  di = abs(p) - vec3(1.);
    float mc = max(di.x, max(di.y, di.z));
    float d =  min(mc,length(max(di,0.0)));
    vec4 res = vec4( d, 1.0, 0.0, 0.0 );

    const mat3 ma = mat3( 0.60, 0.00,  0.80,
                          0.00, 1.00,  0.00,
                          -0.20, 0.00,  0.30 );
    float off = 0.0005;
    float s = 1.0;
    for( int m=0; m<4; m++ ){
        p = ma*(p+off);
        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;
        if( c > d )
            d = c;
    }
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de203.png" alt="fractal_de203", height=200px></td>
</tr>


<tr><td><code>unknown<code></td>
<td><pre> 
float de(vec3 p){
    const float mr=0.25, mxr=1.0;
    const vec4 scale=vec4(-3.12,-3.12,-3.12,3.12),p0=vec4(0.0,1.59,-1.0,0.0);
    vec4 z = vec4(p,1.0);
    for (int n = 0; n < 3; n++) {
        z.xyz=clamp(z.xyz, -0.94, 0.94)*2.0-z.xyz;
        z*=scale/clamp(dot(z.xyz,z.xyz),mr,mxr);
        z+=p0;
    }
    z.y-=3.0*sin(3.0+floor(p.x+0.5)+floor(p.z+0.5));
    float dS=(length(max(abs(z.xyz)-vec3(1.2,49.0,1.4),0.0))-0.06)/z.w;
    return dS;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de204.png" alt="fractal_de204", height=200px></td>
</tr>



<tr><td><code>shane<code></td>
<td><pre> 
mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }
float de(vec3 p){
    float d = 1e5;
    const int n = 3;
    const float fn = float(n);
    for(int i = 0; i < n; i++){
        vec3 q = p;
        float a = float(i)*fn*2.422; //*6.283/fn
        a *= a;
        q.z += float(i)*float(i)*1.67; //*3./fn
        q.xy *= rot2(a);
        float b = (length(length(sin(q.xy) + cos(q.yz))) - .15);
        float f = max(0., 1. - abs(b - d));
        d = min(d, b) - .25*f*f;
    }
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de211.png" alt="fractal_de211", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
 float a=2.,s=3.,e,l=dot(p,p);
 p=abs(p)-1.;
 p.x < p.y?p=p.yxz:p;
 p.x < p.z?p=p.zyx:p;
 p.y < p.z?p=p.xzy:p;
  for(int i=0;i<8;i++){
    s*=e=2.1/clamp(dot(p,p),.1,1.);
    p=abs(p)*e-vec3(.3*l,1,5.*l);
  }
  p-=clamp(p,-a,a);
  return length(p)/s-0.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de212.png" alt="fractal_de212", height=200px></td>
</tr>


<tr><td><code>unknown<code></td>
<td><pre> 
float de(vec3 p0){
    vec4 p = vec4(p0, 1.);

    p.xyz=abs(p.xyz);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 8; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y > p.x)p.yx = p.xy;

        p.xyz = abs(p.xyz);

        p*=(1.8/clamp(dot(p.xyz,p.xyz),.0,1.));
        p.xyz-=vec3(3.6,1.9,0.5);
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return length(p.xyz)/p.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de215.png" alt="fractal_de215", height=200px></td>
</tr>




<tr><td><code>macbooktall<code></td>
<td><pre> 
float de(vec3 p0){
    p0 = mod(p0, 2.)-1.;
    vec4 p = vec4(p0, 1.);
    p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 8; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        
        p.xyz = abs(p.xyz);

        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.6,1.));
        p.xyz-=vec3(0.7,1.8,0.5);
        p*=1.2;

    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return length(p.xyz)/p.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de216.png" alt="fractal_de216", height=200px></td>
</tr>



<tr><td><code>macbooktall<code></td>
<td><pre> 
void pR(inout vec2 p, float a) {
	p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

float de(vec3 p){
    const int iterations = 20;
    float d = -2.; // vary this parameter, range is like -20 to 20
    p=p.yxz;
    pR(p.yz, 1.570795);
    p.x += 6.5;
    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;
    float scale = 1.25;
    p.xy /= (1.+d*d*0.0005);
    
    float l = 0.;
    for (int i=0; i < iterations; i++) {
        p.xy = abs(p.xy);
        p = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);
        pR(p.xy,0.35-d*0.015);
        pR(p.yz,0.5+d*0.02);
        vec3 p6 = p*p*p; p6=p6*p6;
        l =pow(p6.x + p6.y + p6.z, 1./6.);
    }
    return l*pow(scale, -float(iterations))-.15;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de213.png" alt="fractal_de213", height=200px></td>
</tr>

<tr><td><code>nameless<code></td>
<td><pre> 
float de(vec3 p0){
	vec4 p = vec4(p0, 1.);
	p.xyz=abs(p.xyz);
	if(p.x < p.z)p.xz = p.zx;
	if(p.z < p.y)p.zy = p.yz;
	if(p.y < p.x)p.yx = p.xy;
	for(int i = 0; i < 8; i++){
		p.xyz = abs(p.xyz);
		uint seed = uint(p.x+p.y+p.z);
		p*=(2./clamp(dot(p.xyz,p.xyz),0.,1.));
		p.xyz-=vec3(.6,.9,2.2);
	}
	float m = 1.0;
	p.xyz-=clamp(p.xyz,-m,m);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de217.png" alt="fractal_de217", height=200px></td>
</tr>




</table>
<br>



<a id="composed"></a><h2>Composed Shapes</h2>
<p>&nbsp; This section is home to more complex expressions of geometry, showing some different methods of composition. I have put them here if there is more than one or two support functions. Folds and operators are broken out, which may be easier to understand.</p>



<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  <tr>
<tr><td><code>gaziya5 aka gaz<code></td>   
<td><pre> 
#define sabs(a) sqrt(a * a + 0.005)
#define smin(a,b) SMin1(a,b,0.0003)
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float SMin1(float a, float b, float k){
  return a + 0.5 * ((b-a) - sqrt((b-a) * (b-a) + k));
}
vec2 fold(vec2 p, int n){
  p.x=sabs(p.x);
  vec2 v=vec2(0,1);
  for(int i=0;i < n;i++){
    p-=2.0*smin(0.0,dot(p,v))*v;
    v=normalize(vec2(v.x-1.0,v.y));
  }
  return p;    
}
float sdTorus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float de(vec3 p){
  float A=5.566;
  float c=7.0;
  p=mod(p,c)-c*0.5;
  p.xz=fold(p.xz,5);
  for(int i=0;i<5;i++){
    p.xy=abs(p.xy)-2.0;
    p.yz=abs(p.yz)-2.5;
    p.xy*=rot(A);
    p.yz*=rot(A*0.5);
    p=abs(p)-2.0;
  }
  vec2 s=vec2(0.05,0.02);
  float h=0.08;
  float de=1.0;
  vec3 q=p;
  q.xy=fold(q.xy,5);
  q.y-=2.;
  q.x-=clamp(q.x,-h,h);
  de=min(de,sdTorus(q,s));
  q=p;
  q.xy*=rot(M_PI/exp2(5.0));
  q.xy=fold(q.xy,5);
  q.y-=2.0;
  q.x-=clamp(q.x,-h,h);
  de=min(de,sdTorus(q.xzy,s));
  return de;
}</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de39.png" alt="fractal_de39", height=200px></td>
  </tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec4 sphere (vec4 z) {
  float r2 = dot (z.xyz, z.xyz);
  if (r2 < 2.0)
    z *= (1.0 / r2);
  else z *= 0.5;
  return z;
}
vec3 box (vec3 z) {
  return clamp (z, -1.0, 1.0) * 2.0 - z;
}
float DE0 (vec3 pos) {
  vec3 from = vec3 (0.0);
  vec3 z = pos - from;
  float r = dot (pos - from, pos - from) * pow (length (z), 2.0);
  return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;
}
float DE2 (vec3 pos) {
  vec3 params = vec3 (0.5, 0.5, 0.5);
  vec4 scale = vec4 (-20.0 * 0.272321);
  vec4 p = vec4 (pos, 1.0), p0 = p;
  vec4 c = vec4 (params, 0.5) - 0.5; // param = 0..1

  for (float i = 0.0; i < 10.0; i++) {
    p.xyz = box(p.xyz);
    p = sphere(p);
    p = p * scale + c;
  }
  return length(p.xyz) / p.w;
}
float de (vec3 pos) {
  return max (DE0(pos), DE2(pos));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de59.png" alt="fractal_de59", height=200px></td>
</tr>


<tr><td><code>jorge2017a1<code></td>    
<td><pre> 
float de2(vec3 p) {
  vec3 op = p;
  p = abs(1.0 - mod(p, 2.));
  float r = 0., power = 8., dr = 1.;
  vec3 z = p;
  for (int i = 0; i < 7; i++) {
    op = -1.0 + 2.0 * fract(0.5 * op + 0.5);
    float r2 = dot(op, op);
    r = length(z);
    if (r > 1.616) break;
    float theta = acos(z.z / r);
    float phi = atan(z.y, z.x);
    dr = pow(r, power - 1.) * power * dr + 1.;
    float zr = pow(r, power);
    theta = theta * power;
    phi = phi * power;
    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
    z += p;
  }
  return (.5 * log(r) * r / dr);
}

float de1(vec3 p) {
  float s = 1.;
  float d = 0.;
  vec3 r,q;
  r = p;
  q = r;
  for (int j = 0; j < 6; j++) {
    r = abs(mod(q * s + 1.5, 2.) - 1.);	
    r = max(r, r.yzx);
    d = max(d, (.3 - length(r *0.985) * .3) / s);
    s *= 2.1;
  }
  return d;
}
float de(vec3 p) {
  return min(de1(p), de2(p));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de60.png" alt="fractal_de60", height=200px></td>
</tr>
  
  
<tr><td><code>mrange<code></td>    
<td><pre>
void sphere_fold(inout vec3 z, inout float dz) {
const float fixed_radius2 = 1.9;
const float min_radius2   = 0.5;
    float r2 = dot(z, z);
    if(r2 < min_radius2) {
        float temp = (fixed_radius2 / min_radius2);
        z *= temp;
        dz *= temp;
    } else if(r2 < fixed_radius2) {
        float temp = (fixed_radius2 / r2);
        z *= temp;
        dz *= temp;
    }
}
vec3 pmin(vec3 a, vec3 b, vec3 k) {
  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);
  return mix(b, a, h) - k*h*(1.0-h);
}
void box_fold(float k, inout vec3 z, inout float dz) {
  // soft clamp after suggestion from ollij
  const vec3  folding_limit = vec3(1.0);
  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));
  z = zz * 2.0 - z;
}
float sphere(vec3 p, float t) {
  return length(p)-t;
}
float torus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float de(vec3 z) {
    const float scale = -2.8;
    vec3 offset = z;
    float dr = 1.0;
    float fd = 0.0;
    const float k = 0.05;
    for(int n = 0; n < 5; ++n) {
        box_fold(k/dr, z, dr);
        sphere_fold(z, dr);
        z = scale * z + offset;
        dr = dr * abs(scale) + 1.0;        
        float r1 = sphere(z, 5.0);
        float r2 = torus(z, vec2(8.0, 1));        
        float r = n < 4 ? r2 : r1;        
        float dd = r / abs(dr);
        if (n < 3 || dd < fd) {
          fd = dd;
        }
    }
    return fd;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de62.png" alt="fractal_de62", height=200px></td>
</tr>
  
  
<tr><td><code>evilryu<code></td>    
<td><pre>
void sphere_fold(inout vec3 z, inout float dz) {
  float fixed_radius2 = 1.9;
  float min_radius2 = 0.1;
  float r2 = dot(z, z);
  if(r2 < min_radius2) {
    float temp = (fixed_radius2 / min_radius2);
    z *= temp; dz *= temp;
  }else if(r2 < fixed_radius2) {
    float temp = (fixed_radius2 / r2);
    z *= temp; dz *= temp;
  }
}
void box_fold(inout vec3 z, inout float dz) {
  float folding_limit = 1.0;
  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;
}
float de(vec3 z) {
  vec3 offset = z;
  float scale = -2.8;
  float dr = 1.0;
  for(int n = 0; n < 15; ++n) {
    box_fold(z, dr);
    sphere_fold(z, dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;
  }
  float r = length(z);
  return r / abs(dr);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de64.png" alt="fractal_de64", height=200px></td>
</tr>
  
  



<tr><td><code>mrange<code></td>    
<td><pre>
vec3 mod3(inout vec3 p, vec3 size) {
  vec3 c = floor((p + size*0.5)/size);
  p = mod(p + size*0.5, size) - size*0.5;
  return c;
}
void sphere_fold(float fr, inout vec3 z, inout float dz) {
const float fixed_radius2 = 4.5;
const float min_radius2   = 0.5;
  float r2 = dot(z, z);
  if(r2 < min_radius2) {
    float temp = (fr / min_radius2);
    z *= temp;
    dz *= temp;
  } else if(r2 < fr) {
    float temp = (fr / r2);
    z *= temp;
    dz *= temp;
  }
}
void box_fold(float fl, inout vec3 z, inout float dz) {
  z = clamp(z, -fl, fl) * 2.0 - z;
}
float sphere(vec3 p, float t) {
  return length(p)-t;
}
float torus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float mb(float fl, float fr, vec3 z) {
  vec3 offset = z;
  const float scale = -3.0;
  float dr = 1.0;
  float fd = 0.0;
  for(int n = 0; n < 5; ++n) {
    box_fold65(fl, z, dr);
    sphere_fold65(fr, z, dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;        
    float r1 = sphere65(z, 5.0);
    float r2 = torus65(z, vec2(8.0, 1));        
    float r = n < 4 ? r2 : r1;        
    float dd = r / abs(dr);
    if (n < 3 || dd < fd) {
      fd = dd;
    }
  }
  return fd;
}
#define PATHA 0.4*vec2(0.11, 0.21)
#define PATHB 0.7*vec2(13.0, 3.0)
float de(vec3 p) { 
  float tm = p.z;
  const float folding_limit = 2.3;
  const vec3  rep = vec3(10.0);
  
  vec3 wrap = vec3(sin(tm*PATHA)*PATHB, tm);
  vec3 wrapDeriv = normalize(vec3(PATHA*PATHB*cos(PATHA*tm), 1.0));
  p.xy -= wrap.xy;
  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);

  p -= rep*vec3(0.5, 0.0, 0.0);
  p.y *= (1.0 + 0.1*abs(p.y));
  vec3 i = mod3(p, rep);
  
  const float fixed_radius2 = 4.5;
  float fl = folding_limit + 0.3*sin(0.025*p.z+1.0)- 0.3; 
  float fr = fixed_radius2 - 3.0*cos(0.025*sqrt(0.5)*p.z-1.0);

  return mb(fl, fr, p);
} 
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de65.png" alt="fractal_de65", height=200px></td>
</tr>
  
  
  
<tr><td><code>WAHa_06x36<code></td>    
<td><pre>
float periodic(float x,float period,float dutycycle){
  x/=period;
  x=abs(x-floor(x)-0.5)-dutycycle*0.5;
  return x*period;
}
float de(vec3 pos){
  vec3 gridpos=pos-floor(pos)-0.5;
  float r=length(pos.xy);
  float a=atan(pos.y,pos.x);
  a+=12.*0.3*sin(floor(r/3.0)+1.0)*sin(floor(pos.z)*13.73);
  return min(max(max(
  periodic(r,3.0,0.2),
  periodic(pos.z,1.0,0.7+0.3*cos(4.))),
  periodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(4.))),0.25);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de67.png" alt="fractal_de67", height=200px></td>
</tr>
  
  



  
<tr><td><code>dr2<code></td>    
<td><pre>
vec2 Rot2D (vec2 q, float a)
{
  vec2 cs;
  cs = sin (a + vec2 (0.5 * M_PI, 0.));
  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));
}
float PrBoxDf (vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}
float de(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.y = mod (p.y - 4. * a + 2., 4.) - 2.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, 2. * M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de68.png" alt="fractal_de68", height=200px></td>
</tr>
 
  
<tr><td><code>dr2<code></td>    
<td><pre>
vec2 Rot2D(vec2 q, float a)
{
  vec2 cs;
  cs = sin (a + vec2 (0.5 * M_PI, 0.));
  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));
}
float PrBoxDf(vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}
float de(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de69.png" alt="fractal_de69", height=200px></td>
</tr>




<tr><td><code>Kali<code></td>    
<td><pre>
mat2 rot(float a) {
    return mat2(cos(a),sin(a),-sin(a),cos(a));	
}
vec4 formula(vec4 p) {
    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;
    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);
    p.xy*=rot(.5);
    return p;
}
float screen(vec3 p) {
    float d1=length(p.yz-vec2(.25,0.))-.5;	
    float d2=length(p.yz-vec2(.25,2.))-.5;	
    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));
}
float de(vec3 pos) {
    vec3 tpos=pos;
    tpos.z=abs(2.-mod(tpos.z,4.));
    vec4 p=vec4(tpos,1.5);
    float y=max(0.,.35-abs(pos.y-3.35))/.35;

    for (int i=0; i<8; i++) {p=formula(p);}
    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);

    float sc=screen(tpos);
    return min(sc,fr);	
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de70.png" alt="fractal_de70", height=200px></td>
</tr>




<tr><td><code>glkt<code></td>    
<td><pre>
float smin( float a, float b, float k ){
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);
}
float noise(vec3 p){
    vec3 np = normalize(p);
    
    float a = 0.1*snoise2D(np.xy*10.);
    float b = 0.1*snoise2D(0.77+np.yz*10.);
    
    a = mix(a,.5,abs(np.x));
    b = mix(b,.5,abs(np.z));
    return mix(a+b-.4,.5,abs(np.y)/2.);
}
float de(vec3 p){
    float d = (-1.*length(p)+3.)+1.5*noise71(p);    
    d = min(d, (length(p)-1.5)+1.5*noise71(p) );  
    float m = 1.5; float s = .03;    
    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          
    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    
    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    
    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    
    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de71.png" alt="fractal_de71", height=200px></td>
</tr>

<tr><td><code>unconed<code></td>    
<td><pre>
vec4 fold1(vec4 z) {
    vec3 p = z.xyz;
    p = p - 2.0 * clamp(p, -1.0, 1.0);
    return vec4(p, z.w);
}
vec4 fold2(vec4 z) {
    vec3 p = z.xyz;
    p = p - 2.0 * clamp(p, -1.0, 1.0);
    return vec4(p * 2.0, 2.0 * z.w);
}
vec4 invertRadius(vec4 z, float radius2, float limit) {
  float r2 = dot(z.xyz, z.xyz);
  float f = clamp(radius2 / r2, 1., limit);
  return z * f;
}
vec4 affine(vec4 z, float factor, vec3 offset) {
  z.xyz *= factor;
  z.xyz += offset;
  z.w *= abs(factor);
  return z;
}
vec4 mandel(vec4 z, vec3 offset) {
  float x = z.x;
  float y = z.y;
  z.w = 2. * length(z.xy) * z.w + 1.;
  z.x = x*x - y*y + offset.x;
  z.y = 2.*x*y + offset.y;
  return z;
}
vec4 invert(vec4 z, float factor) {
  float r2 = dot(z.xyz, z.xyz);
  float f = factor / r2;
  return z * f;
}
vec4 rotateXY(vec4 z, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2 m = mat2(c, s, -s, c);
  return vec4(m * z.xy, z.zw);
}
vec4 rotateXZ(vec4 z, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2 m = mat2(c, s, -s, c);
  vec2 r = m * z.xz;
  return vec4(r.x, z.y, r.y, z.w);
}
vec4 shiftXY(vec4 z, float angle, float radius) {
  float c = cos(angle);
  float s = sin(angle);
  return vec4(vec2(c, s) * radius + z.xy, z.zw);
}
float de(vec3 p) {
    vec4 z = vec4(p, 1.0);
    float t = 344. * .2; // change this number for different shapes
    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * 1.1;
    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * 1.1;
    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * 1.1;

    z = invertRadius_73(z, 10.0, 1.5);
    z = invertRadius_73(z, 10.0*10.0, 2.0);
    z = rotateXY(z, t);
    z = fold1(z);
    z = rotateXZ(z, t * 1.112);
    z.xyz += vo3;
    z = fold2(z);
    z.xyz += vo1;
    z = affine(z, -1.5, p);
    z = invertRadius(z, 4.0*4.0, 2.0);
    z = affine(z, -1.5, p);
    z = rotateXY(z, t * .881);
    z = fold1(z);
    z = rotateXZ(z, t * .783);
    z = fold1(z);
    z = affine_73(z, -1.5, p);
    z = invertRadius(z, 10.0*10.0, 3.0);
    z = fold1(z);
    z = fold1(z);
    z = affine(z, -1.5, p);
    z = invertRadius(z, 10.0*10.0, 2.0);

    vec3 po = vec3(0.0, 0.0, 0.0);
    vec3 box = abs(z.xyz);
    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;
    float d2 = (max(box.x - 20.0, max(box.y - .5, box.z - .5))) / z.w;
    float d3 = min(d1, d2);
    return d3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de73.png" alt="fractal_de73", height=200px></td>
</tr>




<tr><td><code>lewiz<code></td>    
<td><pre>
void sphereFold(inout vec3 z, inout float dz){
  float r2 = dot(z,z);
  if (r2 < 0.5){ 
    float temp = 2.0;
    z *= temp;
    dz*= temp;
  }else if (r2 < 1.0){ 
    float temp = 1.0 / r2;
    z *= temp; dz*= temp;
  }
}
void boxFold(inout vec3 z, inout float dz){
  z = clamp(z, -1.0, 1.0) * 2.0 - z;
}
float de(vec3 z){
  float scale = 2.0;
  vec3 offset = z;
  float dr = 1.0;
  for (int n = 0; n < 10; n++){
    boxFold(z,dr);
    sphereFold(z,dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;
  }
  float r = length(z);
  return r / abs(dr);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de74.png" alt="fractal_de74", height=200px></td>
</tr>
  
  
  
<tr><td><code>raziel<code></td>    
<td><pre>
float op_u(float d1, float d2){
	return (d1 < d2) ? d1 : d2;
}
void sphere_fold(inout vec3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv){
    float r_sq = dot(p, p);
    if (r_sq < m_rad_sq){
        float t = f_rad_sq * m_rad_sq_inv;
        p *= t;
        dr *= t;
    }
    else if (r_sq < f_rad_sq){
        float t = f_rad_sq / r_sq;
        p *= t;
        dr *= t;
    }
}
void box_fold(inout vec3 p, float fold_limit){
    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;
}
// estimators return (dist, mat_id, custom_value)
float estimator_mandelbox(vec3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit){
    vec3 off = p;
    float dr = 1.0;
    float mrs_inv = 1.0 / m_rad_sq;
    for (int i = 0; i < 10; ++i){
        box_fold(p, fold_limit);
        sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);

        p = scale * p + off;
        dr = dr * abs(scale) + 1.0;
        vec3 ot = p - vec3(0.5);
    }
    return length(p) / abs(dr);
}
vec3 mod_pos(vec3 p, float a, float b){
    p.zx = mod(p.zx, a) - b;  
    return p;
}
float de(vec3 p){
    vec3 p_mb = mod_pos_77(p, 4.4, 2.2);
    float res_mb = estimator_mandelbox(p, -2.5, 0.1, 2.5, 1.0);
    vec3 p_pl = p;
    p_pl.y += 4.0;
    p_pl = mod_pos(p_pl, 2.0, 1.0);
    float res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0);

    return op_u(res_mb, res_pl);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de77.png" alt="fractal_de77", height=200px></td>
</tr>
  
  
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define opRepEven(p,s) mod(p,s)-0.5*s 
#define opRepOdd(p,s) p-s*round(p/s)
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float lpNorm_83(vec3 p, float n){
	p = pow(abs(p), vec3(n));
	return pow(p.x+p.y+p.z, 1.0/n);
}
vec2 pSFold_83(vec2 p,float n){
    float h=floor(log2(n)),a =6.2831*exp2(h)/n;
    for(float i=0.0; i < h+2.0; i++){
	 	vec2 v = vec2(-cos(a),sin(a));
		float g= dot(p,v);
 		p-= (g - sqrt(g * g + 5e-3))*v;
 		a*=0.5;
    }
    return p;
}
vec2 sFold45_83(vec2 p, float k){
    vec2 v = vec2(-1,1)*0.7071;
    float g= dot(p,v);
 	return p-(g-sqrt(g*g+k))*v;
}
float frameBox_83(vec3 p, vec3 s, float r){   
    p = abs(p)-s;
    p.yz=sFold45_83(p.yz, 1e-3);
    p.xy=sFold45_83(p.xy, 1e-3);
    p.x = max(0.0,p.x);
	return lpNorm_83(p,5.0)-r;
}
float sdRoundBox_83( vec3 p, vec3 b, float r ){   
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}
float deObj_83(vec3 p){   
    return min(sdRoundBox_83(p,vec3(0.3),0.05),frameBox_83(p,vec3(0.8),0.1));
}
float de(vec3 p){
    float de=1.0;
    // p.z-=iTime*1.1;
    vec3 q= p;
    p.xy=pSFold_83(-p.xy,3.0);
    p.y-=8.5;
    p.xz=opRepEven(p.xz,8.5);
    float de1=length(p.yz)-1.;
    de=min(de,de1);
    p.xz=pSFold_83(p.xz,8.0);
    p.z-=2.0;
    float rate=0.5;
    float s=1.0;
    for(int i=0;i<3;i++){
        p.xy=abs(p.xy)-.8;
        p.xz=abs(p.xz)-0.5;
        p.xy*=rot(0.2);
        p.xz*=rot(-0.9);
        s*=rate;
        p*=rate;
        de=min(de,deObj_83(p/s));
    }
    q.z=opRepOdd(q.z,8.5);
    float de0=length(q)-1.5;
    de=min(de,de0);
    return de;    
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de83.png" alt="fractal_de83", height=200px></td>
</tr>
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 rot(vec3 p,vec3 a,float t){
	a=normalize(a);
	vec3 v = cross(a,p),u = cross(v,a);
	return u * cos(t) + v * sin(t) + a * dot(p, a);   
}
float lpNorm(vec2 p, float n){
	p = pow(abs(p), vec2(n));
	return pow(p.x+p.y, 1.0/n);
}
float sdTorus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float smin( float a, float b, float k ) {
    float h = clamp(.5+.5*(b-a)/k, 0., 1.);
    return mix(b, a, h) - k*h*(1.-h);
}
float deTetra(vec3 p){
	vec2 g=vec2(-1,1)*0.577;
	return pow(
		pow(max(0.0,dot(p,g.xxx)),8.0)
		+pow(max(0.0,dot(p,g.xyy)),8.0)
		+pow(max(0.0,dot(p,g.yxy)),8.0)
		+pow(max(0.0,dot(p,g.yyx)),8.0),
		0.125);
}
float deStella(vec3 p){
    p=rot(p,vec3(1,2,3),time*3.0);
	return smin(deTetra_85(p)-1.0,deTetra(-p)-1.0,0.05);
}
#define Circle 2.2
vec2 hash2( vec2 p ){
    p = mod(p, Circle*2.0); 
	return fract(sin(vec2(
        dot(p,vec2(127.1,311.7)),
        dot(p,vec2(269.5,183.3))
    ))*43758.5453);
}
vec3 voronoi(vec2 x){
    x*=Circle;
    vec2 n = floor(x);
    vec2 f = fract(x);
	vec2 mg, mr;
    float md = 8.0;
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ ){
        vec2 g = vec2(float(i),float(j));
		vec2 o = hash2( n + g );
		o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );
        vec2 r = g + o - f;
        float d = dot(r,r);
        if( d < md ){
            md = d;
            mr = r;
            mg = g;
        }
    }
    md = 8.0;
    for( int j=-2; j <= 2; j++ )
    for( int i=-2; i <= 2; i++ ){
        vec2 g = mg + vec2(float(i),float(j));
		vec2 o = hash2( n + g );
		o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );
        vec2 r = g + o - f;
        if( dot(mr-r,mr-r)>0.00001 )
        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );
    }
    return vec3( md, mr );
}
float voronoiTorus(vec3 p){
    vec2 size = vec2(12,5);
    vec2 q = vec2(length(p.xz) - size.x, p.y);
	vec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;
	vec3 vr=voronoi(uv*vec2(20,8));
    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));
	return lpNorm(p2,5.0)-0.1; 
}
float fractal(vec3 p)
{   
    vec3 offset = vec3(6,0,0);
    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));
    vec3 co = vec3(cos(time),0,sin(time))*10.0;
    float s1= abs(sin(time))*3.0+2.0;
    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;
    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));
    de=min(de,deS);    
    return de;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de85.png" alt="fractal_de85", height=200px></td>
</tr>
  
  
  
  
  
  
<tr><td><code>iq<code></td>    
<td><pre> 
float maxcomp(in vec3 p ){ 
	return max(p.x,max(p.y,p.z));
}

float sdBox( vec3 p, vec3 b ){
  vec3  di = abs(p) - b;
  float mc = maxcomp(abs(p)-b);
  return min(mc,length(max(di,0.0)));
}

float de(vec3 p){
    vec3 w = p; vec3 q = p;
    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;
    float d = sdBox(q,vec3(1.0));
    float s = 1.0;
    for( int m=0; m<7; m++ ){
        float h = float(m)/6.0;
        p =  q.yzx - 0.5*sin( 1.5*p.x + 6.0 + p.y*3.0 + float(m)*5.0 + vec3(1.0,0.0,0.0));
        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;
        d = max( c, d );
   }
   return d*0.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de132.png" alt="fractal_de132", height=200px></td>
</tr>
  
<tr><td><code>adapted from code by sdfgeoff<code></td>
<td><pre> 
float sdRoundBox( vec3 p, vec3 b, float r ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float df(vec3 co) {
    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);
    co = mod(co, vec3(1.0)) - 0.5;
    return sdRoundBox(co, vec3(rad, rad, 0.3), 0.1);
}

float de(vec3 p){
    float body = 999.0;
    float scale = 0.2;
    vec3 co = p;
    mat4 m = mat4(
		vec4(0.6373087, -0.0796581,  0.7664804, 0.0),
  		vec4(0.2670984,  0.9558195, -0.1227499, 0.0),
  		vec4(-0.7228389,  0.2829553,  0.6304286, 0.0),
        vec4(0.1, 0.6, 0.2, 0.0));
    for (int i=0; i<3; i++) {
        co = (m * vec4(co, float(i))).xyz;
        scale *= (3.0);   
        float field = df(co * scale) / scale;
        body = smin_op(body, field, 0.05);
    }
    return -body;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de189.png" alt="fractal_de189", height=200px></td>
</tr>






<tr><td><code>neozhaoliang<code></td>
<td><pre> 
float mandelbulb(vec3 p)
{
    p /= 1.192;
    p.xyz = p.xzy;
    vec3 z = p;
    vec3 dz = vec3(0.0);
    float dr = 1.0;
    float power = 8.0;
    float r, theta, phi;
    for (int i = 0; i < 7; i++)
    {
        r = length(z);
        if (r > 2.0)
            break;
        float theta = atan(z.y / z.x);
        float phi = asin(z.z / r);
        dr = pow(r, power - 1.0) * power * dr + 1.0;
        r = pow(r, power);
        theta = theta * power;
        phi = phi * power;
        z = r * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;
    }
    return 0.5 * log(r) * r / dr;
}

float sdSponge(vec3 z)
{
    for(int i = 0; i < 9; i++)
    {
        z = abs(z);
        z.xy = (z.x < z.y) ? z.yx : z.xy;
        z.xz = (z.x < z.z) ? z.zx : z.xz;
        z.zy = (z.y < z.z) ? z.yz : z.zy;	 
        z = z * 3.0 - 2.0;
        z.z += (z.z < -1.0) ? 2.0 : 0.0;
    }
    z = abs(z) - vec3(1.0);
    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0)); 
    return dis * 0.6 * pow(3.0, -float(9)); 
}

float de(vec3 p)
{
    float d1 = mandelbulb(p);
    float d2 = sdSponge(p);
    return max(d1, d2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de202.png" alt="fractal_de202", height=200px></td>
</tr>

<tr><td><code>plento<code></td>
<td><pre> 
float sdBox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

vec2 rotate(vec2 k,float t){
  return vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);
}

float de(vec3 pos){
    vec3 b = vec3(0.9 , 4.5, 0.70);
    float p = sin(pos.z * 0.1) * 2.0;
  
    pos = vec3(rotate(pos.xy, p), pos.z);
    pos.y += 1.2;
    pos = mod(pos, b) -0.5 * b;
    pos.x *= sin(length(pos * 1.8) * 2.0) * 1.4;
    
    return sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(0.4));
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de201.png" alt="fractal_de201", height=200px></td>
</tr>



<tr><td><code>russ<code></td>
<td><pre> 
float sdHexPrism( vec3 p, vec2 h ){
  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);
  p = abs(p);
  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;
  vec2 d = vec2(
       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),
       p.z-h.y );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

float sdCrossHex( in vec3 p ){ 
  float sdh1= sdHexPrism(  p-vec3(0.0), vec2(1.0,1.0) );
  float sdh2= sdHexPrism(  p-vec3(0.0), vec2(0.5,1.5) );
  float sdh3= sdHexPrism(  p.xzy-vec3(0.0), vec2(0.5,1.1) );
  float sdh4= sdHexPrism(  p.yzx-vec3(0.0), vec2(0.5,1.5) );
  return max( max( max(sdh1, -sdh2), -sdh3),-sdh4);
}

float sdCrossRep(vec3 p) {
  vec3 q = mod(p + 1.0, 2.0) - 1.0;
  return sdCrossHex(q);
}

float sdCrossRepScale(vec3 p, float s) {
  return sdCrossRep(p * s) / s;	
}

float de(vec3 p) {
  float scale = 3.025;
  float dist= sdHexPrism(p, vec2(1.0,2.0) );
  for (int i = 0; i < 5; i++) {
    dist = max(dist, -sdCrossRepScale(p, scale));
    scale *= 3.0;
  }
  return dist;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de205.png" alt="fractal_de205", height=200px></td>
</tr>


<tr><td><code>russ<code></td>
<td><pre> 
float sdTriPrism( vec3 p, vec2 h ){
    vec3 q = abs(p);
    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);
}

float sdCrossHex( in vec3 p ){
    float sdfin=1000.0;
    float sdt1= sdTriPrism( p- vec3(0.0), vec2(1.0) );
    float sdt2= sdTriPrism( -p.xyz- vec3(0.0), vec2(0.5,1.2) );
    float sdt3= sdTriPrism( p.xzy- vec3(0.0), vec2(0.5,1.2) );
    sdfin =max(sdt1, -sdt2);
    sdfin =max(sdfin, -sdt3);
    return sdfin;
}

float sdCrossRep(vec3 p) {
	vec3 q = mod(p + 1.0, 2.0) - 1.0;
	return sdCrossHex(q);
}

float sdCrossRepScale(vec3 p, float s) {
	return sdCrossRep(p * s) / s;	
}

float de(vec3 p) {
    float scale = 4.0;
    float dist=sdTriPrism( p-vec3(0.0), vec2(1.0,1.0) );
	for (int i = 0; i < 5; i++) {
		dist = max(dist, -sdCrossRepScale(p, scale));
		scale *= 3.0;
	}
	return dist;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de207.png" alt="fractal_de207", height=200px></td>
</tr>


<tr><td><code>russ<code></td>
<td><pre> 
float cylUnion(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(min(xy,min(xz,yz))) - 1.;
}

float cylIntersection(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(max(xy,max(xz,yz))) - 1.;
}

float DE(vec3 p){
  float d = cylIntersection(p);
  float s = 1.;
  for(int i = 0;i<5;i++){
    p *= 3.; s*=3.;
    float d2 = cylUnion(p) / s;
    d = max(d,-d2);
    p = mod(p+1. , 2.) - 1.; 	
  }
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de208.png" alt="fractal_de208", height=200px></td>
</tr>


<tr><td><code>russ<code></td>
<td><pre> 
float cylUnion(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(min(xy,min(xz,yz))) - 1.;
}

float cylIntersection(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(max(xy,max(xz,yz))) - 1.;
}

float DE(vec3 p){
  float d = cylIntersection(p);
  float s = 1.;
  for(int i = 0;i<5;i++){
    p *= 3.; s*=3.;
    float d2 = cylUnion(p) / s;
    d = max(d,d2);
    p = mod(p+1. , 2.) - 1.; 	
  }
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de209.png" alt="fractal_de209", height=200px></td>
</tr>



<tr><td><code>jorge2017a1<code></td>
<td><pre>
float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}
float sdBox( vec3 p, vec3 b ){
  vec3  di = abs(p) - b;
  float mc = maxcomp(di);
  return min(mc,length(max(di,0.0)));
}

float cylUnion(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(min(xy,min(xz,yz))) - 1.;
}

float cylIntersection(vec3 p){
  float xy = dot(p.xy,p.xy);
  float xz = dot(p.xz,p.xz);
  float yz = dot(p.yz,p.yz);
  return sqrt(max(xy,max(xz,yz))) - 1.;
}

float dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)
{
  vec3 ap = point_p - point_a;
  vec3 ab = point_b - point_a;
  float ratio = dot(ap, ab) / dot(ab , ab);
  ratio = clamp(ratio, 0.0, 1.0);
  vec3 point_c = point_a + ratio * ab;
  return length(point_c - point_p) - r;
}

float DE(vec3 p){
  float d = dsCapsule(vec3(-0.0,0.0,0.0), vec3(2.0,1.0,0.1), 1.0, p);
  float s = 1.;
  for(int i = 0;i<5;i++){
    p *= 3.; s*=3.;
    float d2 = cylUnion(p) / s;
    float d3=sdBox(p, vec3(2.0,1.0,2.5));
    d = max(d,-d2);
    p = mod(p+1. , 2.) - 1.; 	
  }
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de210.png" alt="fractal_de210", height=200px></td>
</tr>




<tr><td><code>butadiene<code></td>
<td><pre> 
Large Sierpinski area with cube superstructure

mat2 rot(float r){
  vec2 s = vec2(cos(r),sin(r));
  return mat2(s.x,s.y,-s.y,s.x);
}
float cube(vec3 p,vec3 s){
  vec3 q = abs(p);
  vec3 m = max(s-q,0.);
  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);
}
float tetcol(vec3 p,vec3 offset,float scale,vec3 col){
  vec4 z = vec4(p,1.);
  for(int i = 0;i<12;i++){
    if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;
    if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;
    if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;
    z *= scale;
    z.xyz += offset*(1.0-scale);
  }
  return (cube(z.xyz,vec3(1.5)))/z.w;
}
float de(vec3 p){
  float s = 1.;
  p = abs(p)-4.*s;
  p = abs(p)-2.*s;
  p = abs(p)-1.*s;
  return tetcol(p,vec3(1),1.8,vec3(0.));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de206.png" alt="fractal_de206", height=200px></td>
</tr>







<tr><td><code>tholzer<code></td>
<td><pre>
IcoDodecaStar

// Dodecahedron: radius = circumsphere radius
float sdDodecahedron(vec3 p, float radius){
  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;
  const vec3 n = normalize(vec3(phi,1,0));

  p = abs(p / radius);
  float a = dot(p, n.xyz);
  float b = dot(p, n.zxy);
  float c = dot(p, n.yzx);
  return (max(max(a,b),c)-n.x) * radius;
}
// Icosahedron: radius = circumsphere radius
float sdIcosahedron(vec3 p, float radius){
  const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;
  const vec3 n1 = normalize(vec3(q,1,0));
  const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);

  p = abs(p / radius);
  float a = dot(p, n1.xyz);
  float b = dot(p, n1.zxy);
  float c = dot(p, n1.yzx);
  float d = dot(p, n2) - n1.x;
  return max(max(max(a,b),c)-n1.x,d) * radius;
}
float de(vec3 p){
  float radius = 0.5;
  return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/icododecastar.png" alt="icododecastar", height=200px></td>
</tr>


<tr><td><code>tholzer<code></td>
<td><pre>
Rack Wheel

#define opRepeat(p,c) (mod(p,c)-0.5*c)
#define opDifference(a,b) max(a,-b)

float length2( vec2 p ) {
  return sqrt( p.x*p.x + p.y*p.y );
}

float length8( vec2 p ) {
  p = p*p; p = p*p; p = p*p;
  return pow( p.x + p.y, 1.0/8.0 );
}

float sdCylinder (in vec3 p, in vec3 h){
  return length(p.xz - h.xy) - h.z;
}

float sdTorus82( vec3 p, vec2 t ){
  vec2 q = vec2(length2(p.xz)-t.x, p.y);
  return length8(q) - t.y;
}

float de( in vec3 pos){
  return opDifference(sdTorus82(pos, vec2(0.20, 0.1)),
    sdCylinder (opRepeat (vec3 (atan(pos.x, pos.z)/6.2831
                                ,pos.y
                                ,0.02+0.5*length(pos))
                          ,vec3(0.05, 1.0, 0.05))
                ,vec2(0.02, 0.6)));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/rackwheel.png" alt="rack wheel", height=200px></td>
</tr>








  
</table>
<br>



<a id="licensing"></a><h2>Licensing</h2>
<p>
&nbsp; This is an educational resource provided under the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode"> CC Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>. 

</p>

<p>
&nbsp; This is the default Shadertoy license unless otherwise specified by the shader author, the same license provided with the hg_sdf header. There are some utility functions referenced which are provided by the <a href="../resources/noise.glsl">Twigl noise header</a>, available under the MIT license, and the <a href="../resources/hg_sdf.glsl">hg_sdf header</a>. The primitives provided by Inigo Quilez are under the <a href="images/DEC/inigo.txt">MIT License</a>.
</p>

<p>
&nbsp; I have gathered these distance estimator functions from several sources (discussions with individuals, the hg_sdf header, Shadertoy examples, code deobfuscated from the #つぶやきGLSL tag on Twitter, among others). I have done my best to give credit to the authors, but I do not have a complete record - if you have information to that end, please contact me via email. If you are doing something cool with them, or would like to contribute to this resource, please contact me at jb239812@ohio.edu.
</p>

</div>
<br>
<p>Last updated 5/27/2021</p>
</body>
</html>
