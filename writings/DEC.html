<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Distance Estimator Compendium (DEC)</title>

<style>
body {
	font-family: 'Rokkitt', serif;
	color:#481203;
    background-color: #f7f0de;
    margin: 50px 50px 50px 100px;
    line-height: 15px;
}
a:link,
a:visited {
 color:blue;
 text-decoration:none;
 transition:.85s ease-out
}
a:hover {
 color:#FF1203;
 text-decoration:none;
 transition:0s
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
  text-align: Left;
  padding: 4px;
}

td.fitwidth {
    width: 1px;
    white-space: nowrap;
}

td.fitwidth:hover img {
	height:480px;
}

</style>

<style>
@import url('https://fonts.googleapis.com/css2?family=Rokkitt:wght@600&display=swap');
</style>
<link rel = "icon" href = "https://jbaker.graphics/resources/icon.png" type = "image/x-icon">
</head>
<body>

<h1 style='display:inline-block'>Jon Baker, Graphics Programming</h1>
<p style='display:inline-block'> &nbsp; &nbsp; <a href='../index.html'>home</a></p>
<p style='display:inline-block'> &nbsp; &nbsp; <a href='index.html'>writings</a></p>

<div style='width:768px;'>

<h2>The Distance Estimator Compendium (DEC)</h2>


<a href="#introduction" style="font-size:120%;">&nbsp; > Introduction</a><br />
<a href="#simple"       style="font-size:120%;">&nbsp; > Simple Primitives</a><br />
<a href="#operators"    style="font-size:120%;">&nbsp; > Operators</a><br />
<a href="#fractals"     style="font-size:120%;">&nbsp; > Fractals</a><br />
<a href="#composed"     style="font-size:120%;">&nbsp; > Composed Shapes</a><br />
<a href="#licensing"    style="font-size:120%;">&nbsp; > Licensing</a><br />

<a id="introduction"></a><h2>Introduction</h2>
<p>
&nbsp;My goal here is to provide a collected resource of these signed distance functions (SDFs) in a standardized format given by <code>float de( vec3 p ){...}</code>. 
</p>
<p>
&nbsp;SDFs are an interesting method for representing geometry as an implicit functional representation, which produces a result by querying with a given point in space and returning an estimate of the distance to the surface - positive outside, and negative inside. I emphasize that this result is an estimate, especially for some of the fractal SDFs which produce a result by distorting the space in a highly nonlinear fashion.
</p>
<p>
&nbsp;This representation is often used in realtime raymarching, but they come up in applications such as pathtracing and producing of meshes. I have seen several resources on this topic but I hope to gather as much as I can in one place on this page.
</p>

<p>
&nbsp;Mouse over each of the images to view it larger.
</p>


<a id="simple"></a><h2>Simple Primitives</h2>
<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  
  
<tr><td><code>hg_sdf<code></td>    
<td><pre>
Sphere

float de(vec3 p){
  float r = 1; // the radius
  return length(p) - r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/sphere.png" alt="sphere", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Plane

float de(vec3 p){
  vec3 n = vec3(0.,1.,0.);       // plane's normal vector
  float distanceFromOrigin = 0.; // position along normal
  
  return dot(p, n) + distanceFromOrigin;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/plane.png" alt="plane", height=200px></td>
</tr>



<tr><td><code>hg_sdf<code></td>    
<td><pre>
Box

float de(vec3 p){ // cheap version
  vec3 size = vec3(1.); //dimensions on each axis 
  vec3 d = abs(p) - size;

  return max(max(d.x, d.y), d.z);
}

float de(vec3 p){
  vec3 size = vec3(1.) // dimensions on each axis
  vec3 d = abs(p) - size;
  float md = min(d, vec3(0));
  
  return length(max(d, vec3(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/box.png" alt="box", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
2d Infinite Box

float de(vec3 p){  // cheap version
  vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)
  vec2 bd = vec2(1.) // the dimensions of the box
  vec2 d = abs(p0) - bd;
  
  return max(d.x, d.y);
}

float de(vec3 p){
  vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)
  vec2 bd = vec2(1.) // the dimensions of the box
  vec2 d = abs(p0) - bd;
  vec2 md = min(d, vec2(0.));
  
  return length(max(d, vec2(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/box2d.png" alt="box", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Endless Corner/Shelf

float de(vec3 p){
  vec2 p0 = p.xy; // the plane the section lies in
  vec2 md = min(p, vec2(0));

  return length(max(p0, vec2(0))) + max(max(md.x, md.y), md.z);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/corner.png" alt="corner", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Blob - not a correct distance bound, has artifacts

float de(vec3 p) {
  p = abs(p);
  if (p.x < max(p.y, p.z)) p = p.yzx;
  if (p.x < max(p.y, p.z)) p = p.yzx;
  float b = max(max(max(
    dot(p, normalize(vec3(1, 1, 1))),
    dot(p.xz, normalize(vec2(PHI+1, 1)))),
    dot(p.yx, normalize(vec2(1, PHI)))),
    dot(p.xz, normalize(vec2(1, PHI))));
  float l = length(p);
  return l - 1.5 - 0.2 * (1.5 / 2)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/blob.png" alt="blob", height=200px></td>
</tr>



<tr><td><code>hg_sdf<code></td>    
<td><pre>
Cylinder in the XZ plane

float de(vec3 p){
  float r = 1.;
  float height = 1.;
  
  float d = length(p.xz) - r;
  d = max(d, abs(p.y) - height);
  
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cylinder.png" alt="cylinder", height=200px></td>
</tr>



<tr><td><code>hg_sdf<code></td>    
<td><pre>
Capsule - cylinder with round caps

float de(vec3 p)
  float r = 1.; // radius
  float c = 1.; // length
  return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));
}

Alternate method

float de_line_segment(vec3 p, vec3 a, vec3 b) {
  vec3 ab = b - a;
  float t = clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.);
  
  return length((ab*t + a) - p);
}

float de(vec3 p){
  vec3 a = vec3(0., -1., 0.); // location of top
  vec3 b = vec3(0.,  1., 0.); // location of bottom
  float r = 1.; // radius

  return de_line_segment(p, a, b) - r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/capsule.png" alt="capsule", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Torus

float de(vec3 p){
  float smallRadius = 1.; // minor radius
  float largeRadius = 2.; // major radius

  return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

Alternate method using circular line SDF - subtract minor radius from result

float de(vec3 p){
  float r = 1.; // major radius
  float l = length(p.xz) - r;
  
  return length(vec2(p.y, l));
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/torus.png" alt="torus", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
2D Disc - no thickness - subtract some amount from result to make a rounded disk

float de(vec3 p){
  float r = 1.; // radius of the circle
  float l = length(p.xz) - r;
  
  return length(vec2(p.y, l));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/disk.png" alt="disk", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Hexagonal Prism

Circumcircle Variant

float de(vec3 p){
  float width = 1.;
  float height = 1.;
  
  return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - width);
}

Incircle Variant

float de(vec3 p){
  float width = 1.;
  float height = 1.;
  vec3 q = abs(p);

  return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - (width*sqrt(3)*0.5));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/hexagon.png" alt="hexagon", height=200px></td>
</tr>


<tr><td><code>hg_sdf<code></td>    
<td><pre>
Cone - pointing up the y axis

float de(vec3 p){
  float radius = 1.;
  float height = 3.;
  vec2 q = vec2(length(p.xz), p.y);
  vec2 tip = q - vec2(0, height);
  vec2 mantleDir = normalize(vec2(height, radius));
  float mantle = dot(tip, mantleDir);
  float d = max(mantle, -q.y);
  float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));

  // distance to tip
  if ((q.y > height) && (projected < 0)) {
    d = max(d, length(tip));
  }

  // distance to base ring
  if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
    d = max(d, length(q - vec2(radius, 0)));
  }
  return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/cone.png" alt="cone", height=200px></td>
</tr>


<tr><td><code>Akleman and Chen via hg_sdf<code></td>    
<td><pre>
Generalized Distance Functions - Support for the following Polyhedra

const vec3 GDFVectors[19] = vec3[](
  normalize(vec3(1, 0, 0)),
  normalize(vec3(0, 1, 0)),
  normalize(vec3(0, 0, 1)),

  normalize(vec3(1, 1, 1 )),
  normalize(vec3(-1, 1, 1)),
  normalize(vec3(1, -1, 1)),
  normalize(vec3(1, 1, -1)),

  normalize(vec3(0, 1, PHI+1)),
  normalize(vec3(0, -1, PHI+1)),
  normalize(vec3(PHI+1, 0, 1)),
  normalize(vec3(-PHI-1, 0, 1)),
  normalize(vec3(1, PHI+1, 0)),
  normalize(vec3(-1, PHI+1, 0)),

  normalize(vec3(0, PHI, 1)),
  normalize(vec3(0, -PHI, 1)),
  normalize(vec3(1, 0, PHI)),
  normalize(vec3(-1, 0, PHI)),
  normalize(vec3(PHI, 1, 0)),
  normalize(vec3(-PHI, 1, 0))
);

// Version with variable exponent.
// This is slow and does not produce correct distances, but allows for bulging of objects.
float fGDF(vec3 p, float r, float e, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d += pow(abs(dot(p, GDFVectors[i])), e);
	return pow(d, 1/e) - r;
}

// Version with without exponent, creates objects with sharp edges and flat faces
float fGDF(vec3 p, float r, int begin, int end) {
	float d = 0;
	for (int i = begin; i <= end; ++i)
		d = max(d, abs(dot(p, GDFVectors[i])));
	return d - r;
}
</pre></td>
<td></td>
</tr>


<tr><td></td>    
<td><pre>
Octahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 6);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 6);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/octahedron.png" alt="octahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Dodecahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 13, 18);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 13, 18);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/dodecahedron.png" alt="dodecahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Icosahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 12);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 12);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/icosahedron.png" alt="icosahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Truncated Octahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 0, 6);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 0, 6);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/truncated_octahedron.png" alt="truncated octahedron", height=200px></td>
</tr>

<tr><td></td>    
<td><pre>
Truncated Icosahedron

float de(vec3 p){
  float r = 1.; // radius
  
  return fGDF(p, r, 3, 18);
}

With Exponent

float de(vec3 p){
  float r = 1.; // radius
  float e = 1.; // exponent
  
  return fGDF(p, r, e, 3, 18);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/primitives/truncated_icosahedron.png" alt="truncated icosahedron", height=200px></td>
</tr>




</table>
<br>


<a id="operators"></a><h2>Operators</h2>
<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>



<tr><td><code>WIP<code></td>    
<td><pre>
WIP
</pre></td>
<td class="fitwidth"><img src="images/DEC/WIP.png" alt="WIP", height=200px></td>
</tr>




</table>
<br>




<a id="fractals"></a><h2>Fractals</h2>
<p>&nbsp; These are very concise expressions of complex geometry, with operations condensed to their simplest expressions. Many of these have been deobfuscated from minimized #つぶやきGLSL examples. The forms are highly complex and often use magic numbers to control geometry - these provide opportunities to manipulate the forms, and may provide insight for those with the motivation to in dig into it. </p>

<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  
  
  
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    p.xyz = mod(p.xyz-1.,2.)-1.;
    p*=1.4/dot(p.xyz,p.xyz);
  }
  return (length(p.xz/p.w)*0.25);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de.png" alt="fractal_de", height=200px></td>
</tr>
  
  <!-- fractal_de2 looks like shit -->
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=(1.2/dot(p.xyz,p.xyz));
  }
  p/=p.w;
  return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de3.png" alt="fractal_de3", height=200px></td>
</tr>
  
  
<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    p = abs(p);
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=1.23;
  }
  p/=p.w;
  return abs(p.y)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de4.png" alt="fractal_de4", height=200px></td>
</tr>
  
  

<tr><td><code>unknown<code></td>    
<td><pre>
float de( vec3 pos ) 
{
#define SCALE 2.8
#define MINRAD2 .25
#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)
  float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);
  float absScalem1 = abs(SCALE - 1.0);
  float AbsScale = pow(abs(SCALE), float(1-10));
  vec4 p = vec4(pos,1);
  vec4 p0 = p;
  for (int i = 0; i < 9; i++)
  {
    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    float r2 = dot(p.xyz, p.xyz);
    p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
    p = p*scale + p0;
  }
  return ((length(p.xyz) - absScalem1) / p.w - AbsScale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de5.png" alt="fractal_de5", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){ 
  p = p.xzy;
  vec3 cSize = vec3(1., 1., 1.3);
  float scale = 1.;
  for( int i=0; i < 12; i++ ){
    p = 2.0*clamp(p, -cSize, cSize) - p;
    float r2 = dot(p,p);
    float k = max((2.)/(r2), .027);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 4.0;
  float n = l * p.z;
  rxy = max(rxy, -(n) / 4.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de6.png" alt="fractal_de6", height=200px></td>
</tr>
  





<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  p = p.xzy;
  vec3 cSize = vec3(1., 1., 1.3);
  float scale = 1.;
  for( int i=0; i < 12;i++ ){
    p = 2.0*clamp(p, -cSize, cSize) - p;
    float r2 = dot(p,p+sin(p.z*.3));
    float k = max((2.)/(r2), .027);
    p *= k;  scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 4.0;
  float n = l * p.z;
  rxy = max(rxy, -(n) / 4.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de7.png" alt="fractal_de7", height=200px></td>
</tr>




<tr><td><code>iq<code></td>    
<td><pre>
float de( vec3 p ){
  float scale = 1.0;
  float orb = 10000.0;
  for( int i=0; i<6; i++ ){
    p = -1.0 + 2.0*fract(0.5*p+0.5);
    p -= sign(p)*0.04; // trick
    float r2 = dot(p,p);
    float k = 0.95/r2;
    p  *= k;  scale *= k;
    orb = min( orb, r2);
  }

  float d1 = sqrt( min( min( dot(p.xy,p.xy), 
    dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;
  float d2 = abs(p.y);
  float dmi = d2;
  if( d1 < d2 ) dmi = d1;
  return 0.5*dmi/scale;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de8.png" alt="fractal_de8", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  vec3 CSize = vec3(1., 1.7, 1.);
  p = p.xzy;
  float scale = 1.1;
  for( int i=0; i < 8;i++ ){
    p = 2.0*clamp(p, -CSize, CSize) - p;
    float r2 = dot(p,p);
    float k = max((2.)/(r2), .5);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 1.0;
  float n = l * p.z;
  rxy = max(rxy, (n) / 8.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de9.png" alt="fractal_de9", height=200px></td>
</tr>




<tr><td><code>unknown<code></td>    
<td><pre>
// highly varied domain - take a look around
float de( vec3 p ){
  vec3 CSize = vec3(1., 1.7, 1.);
  p = p.xzy;
  float scale = 1.1;
  for( int i=0; i < 8;i++ ){
    p = 2.0*clamp(p, -CSize, CSize) - p;
    float r2 = dot(p,p+sin(p.z*.3));
    float k = max((2.)/(r2), .5);
    p *= k; scale *= k;
  }
  float l = length(p.xy);
  float rxy = l - 1.0;
  float n = l * p.z;
  rxy = max(rxy, (n) / 8.);
  return (rxy) / abs(scale);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de10.png" alt="fractal_de10", height=200px></td>
</tr>

  <!-- fractal_de11 looks like shit -->

<tr><td><code>unknown<code></td>    
<td><pre>
vec3 fold( vec3 p0 ){
  vec3 p = p0;
  if(length(p) > 1.2) return p;
  p = mod(p,2.)-1.;
  return p;
}

float de( vec3 p0 ){
  vec4 p = vec4(p0, 1.);
  for(int i = 0; i < 12; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    p = abs(p);
    p.xyz = fold(p.xyz);
    p.xyz = mod(p.xyz-1., 2.)-1.;
    p*=(1.2/dot(p.xyz,p.xyz));
  }
  p/=p.w;
  return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de12.png" alt="fractal_de12", height=200px></td>
</tr>


  <!-- fractal_de13 looks like shit -->
  <!-- fractal_de14 looks like shit -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
float de( vec3 p ){
  p=abs(p)-1.2;
  if(p.x < p.z)p.xz=p.zx;
  if(p.y < p.z)p.yz=p.zy;
  if(p.x < p.y)p.xy=p.yx;
  float s=1.;
  for(int i=0;i<6;i++){
    p=abs(p);
    float r=2./clamp(dot(p,p),.1,1.);
    s*=r; p*=r; p-=vec3(.6,.6,3.5);
  }
  float a=1.5;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de15.png" alt="fractal_de15", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
float de( vec3 p ){
    // box fold
    p=abs(p)-15.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=2.;
    for (int i=0; i<8; i++){
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        float r=-1.55/max(.41,dot(p,p));
        s*=r; p*=r; p-=.5;
    }
    s=abs(s);
    return dot(p,normalize(vec3(1,2,3)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de16.png" alt="fractal_de16", height=200px></td>
</tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre>
void sFold90( inout vec2 p ){
    vec2 v=normalize(vec2(1,-1));
    float g=dot(p,v);
    p-=(g-sqrt(g*g+1e-1))*v;
}

float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-1.8;
    sFold90(p.zy);
    sFold90(p.xy);
    sFold90(p.zx);
    float s=2.;
    vec3  offset=p*.5;
    for(int i=0;i<8;i++){
        p=1.-abs(p-1.);
        float r=-1.3*max(1.5/dot(p,p),1.5);
        s*=r; p*=r; p+=offset;
        p.zx*=rot(-1.2);
    }
    s=abs(s); float a=8.5;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de17.png" alt="fractal_de17", height=200px></td>
</tr>
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm( vec3 p, float n ){
    p = pow(abs(p), vec3(n));
    return pow(p.x+p.y+p.z, 1.0/n);
}

float de( vec3 p ){
  vec3 offset=p*.5;
  float s=2.;
  for (int i=0; i<5; i++){
    p=clamp(p,-1.,1.)*2.-p;
    float r=-10.*clamp(max(.3/pow(
    lpNorm(p,5.),2.),.3),.0,.6);
    s*=r; p*=r; p+=offset;
  }
  s=abs(s); float a=10.;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de18.png" alt="fractal_de18", height=200px></td>
</tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define sabs1(p)sqrt((p)*(p)+1e-1)
#define sabs2(p)sqrt((p)*(p)+1e-3)
float de( vec3 p ){
  float s=2.; p=abs(p);
  for (int i=0; i<4; i++){
    p=1.-sabs2(p-1.);
    float r=-9.*clamp(max(.2/pow(min(min(sabs1(p.x),
      sabs1(p.y)),sabs1(p.z)),.5), .1), 0., .5);
    s*=r; p*=r; p+=1.;
  }
  s=abs(s); float a=2.;
  p-=clamp(p,-a,a);
  return length(p)/s-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de19.png" alt="fractal_de19", height=200px></td>
</tr>
  
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=3.;
    for(int i = 0; i < 4; i++) {
        p=mod(p-1.,2.)-1.;
        float r=1.2/dot(p,p);
        p*=r; s*=r;
    }
    p = abs(p)-0.8;
    if (p.x < p.z) p.xz = p.zx;
    if (p.y < p.z) p.yz = p.zy;
    if (p.x < p.y) p.xy = p.yx;
    return length(cross(p,normalize(vec3(0,1,1))))/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de20.png" alt="fractal_de20", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=3.; p=abs(p);
    for (float i=0.; i<9.; i++){
        p-=clamp(p,-1.,1.)*2.;
        float r=6.62*clamp(.12/min(dot(p,p),1.),0.,1.);
        s*=r; p*=r; p+=1.5;
    }
    s=abs(s); float a=.8;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de21.png" alt="fractal_de21", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    float s=12.; p=abs(p);
    vec3 offset=p*3.;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-5.5*clamp(.3*max(2.5/dot(p,p),.8),0.,1.5);
        p*=r; p+=offset; s*=r;
    }
    s=abs(s); p=abs(p)-3.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float a=3.;
    p-=clamp(p,-a,a);
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de22.png" alt="fractal_de22", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-3.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=3.;
    vec3  offset=p*1.2;
    for (float i=0.;i<8.;i++){
        p=1.-abs(p-1.);
        float r=-6.5*clamp(.41*max(1.1/dot(p,p),.8),.0,1.8);
        s*=r; p*=r; p+=offset;
        p.yz*=rot(-1.2);
    }
    s=abs(s);
    float a=20.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de23.png" alt="fractal_de23", height=200px></td>
</tr>






<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
    p=abs(p)-2.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=2.5;
    vec3 off=p*2.8;
    for (float i=0.;i<6.;i++) {
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        float r=-11.*clamp(.8*max(2.5/dot(p,p),.2),.3,.6);
        s*=r; p*=r; p+=off;
        p.yz*=rot(2.1);
    }
    s=abs(s);
    float a=30.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de24.png" alt="fractal_de24", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    p=abs(p);
    float s=3.;
    vec3  offset = p*.5;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-3.*clamp(.57*max(3./dot(p,p),.9),0.,1.);
        s*=r; p*=r; p+=offset;
    }
    s=abs(s);
    return length(cross(p,normalize(vec3(1))))/s-.008;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de25.png" alt="fractal_de25", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
    p.xy=abs(p.xy)-2.;
    if(p.x < p.y)p.xy=p.yx;
    p.z=mod(p.z,4.)-2.;
    p.x-=3.2; p=abs(p);
    float s=2.;
    vec3 offset= p*1.5;
    for (float i=0.; i<5.; i++){
        p=1.-abs(p-1.);
        float r=-7.5*clamp(.38*max(1.2/dot(p,p),1.),0.,1.);
        s*=r; p*=r; p+=offset;
    }
    s=abs(s);
    float a=100.;
    p-=clamp(p,-a,a);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de26.png" alt="fractal_de26", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  float s=1.;
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy=abs(p.xy)-.2;
    p.xy*=rot(.3);
    p.yz*=rot(.3);
    p*=2.; s*=2.;
  }
  p/=s;
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de27.png" alt="fractal_de27", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=1.;
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy-=.2; p*=2.; s*=2.;
  }
  p/=s;
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de28.png" alt="fractal_de28", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  for(int i=0;i<3;i++){
    p=abs(p)-.3;
    if(p.x < p.y)p.xy=p.yx;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    p.xy-=.2; p.xy*=rot(.5); p.yz*=rot(.5);
  }
  float h=.5;
  p.x-=clamp(p.x,-h,h);
  return length(vec2(length(p.xy)-.5,p.z))-.05;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de29.png" alt="fractal_de29", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define TAUg atan(1.)*8.
vec2 pmodg(vec2 p, float n){
  float a=mod(atan(p.y, p.x),TAUg/n)-.5 *TAUg/n;
  return length(p)*vec2(sin(a),cos(a));
}

float de( vec3 p ){
    for(int i=0;i<4;i++){
        p.xy = pmodg(p.xy,10.);  p.y-=2.;
        p.yz = pmodg(p.yz, 12.); p.z-=10.;
    }
    return dot(abs(p),normalize(vec3(13,1,7)))-.7;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de30.png" alt="fractal_de30", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.x-=4.;
  p=mod(p,8.)-4.;
  for(int j=0;j<3;j++){
     p.xy=abs(p.xy)-.3;
     p.yz=abs(p.yz)+.7,
     p.xz=abs(p.xz)-.2;
  }
  return length(cross(p,vec3(.5)))-.1;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de31.png" alt="fractal_de31", height=200px></td>
</tr>


  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 fold(vec3 p0){
    vec3 p = p0;
    if(length(p) > 2.)return p;
    p = mod(p,2.)-1.;
    return p;
}

float de( vec3 p0 ){
    vec4 p = vec4(p0, 1.);
    escape = 0.;
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p = abs(p);
    for(int i = 0; i < 8; i++){
        p.xyz = fold(p.xyz);
        p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;
        p*=(1.1/clamp(dot(p.xyz,p.xyz),-0.1,1.));
    }
    p/=p.w;
    return abs(p.x)*0.25;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de32.png" alt="fractal_de32", height=200px></td>
</tr>


    <!-- fractal_de33 crashes -->    
    <!-- fractal_de34 crashes -->
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
    p=mod(p,2.)-1.;
    p=abs(p)-1.;
    if(p.x < p.z)p.xz=p.zx;
    if(p.y < p.z)p.yz=p.zy;
    if(p.x < p.y)p.xy=p.yx;
    float s=1.;
    for(int i=0;i<10;i++){
      float r2=2./clamp(dot(p,p),.1,1.);
      p=abs(p)*r2-vec3(.6,.6,3.5);
      s*=r2;
    }
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de35.png" alt="fractal_de35", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
	float itr=10.,r=0.1;
	p=mod(p-1.5,3.)-1.5;
	p=abs(p)-1.3;
	if(p.x < p.z)p.xz=p.zx;
	if(p.y < p.z)p.yz=p.zy;
 	if(p.x < p.y)p.xy=p.yx;
	float s=1.;
	p-=vec3(.5,-.3,1.5);
	for(float i=0.;i++ < itr;) {
		float r2=2./clamp(dot(p,p),.1,1.);
		p=abs(p)*r2;
		p-=vec3(.7,.3,5.5);
		s*=r2;
	}
   return length(p.xy)/(s-r);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de36.png" alt="fractal_de36", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ) {
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++) {
    p=1.-abs(p-1.);
    r2=1.2/dot(p,p); 
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.003;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de37.png" alt="fractal_de37", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++) {
    p=1.-abs(p-1.);
    r2=(i%3==1)?1.3:1.3/dot(p,p);
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.003;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de38.png" alt="fractal_de38", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define fold45(p)(p.y>p.x)?p.yx:p
float de(vec3 p) {
  float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
  vec3 off =vec3(2.,.2,.1);
  float s=1.0;
  for(int i = 0;++i<20;) { 
    p.xy = abs(p.xy);
    p.xy = fold45(p.xy);
    p.y -= off0;
    p.y = -abs(p.y);
    p.y += off0;
    p.x += off1;
    p.xz = fold45(p.xz);
    p.x -= off2;
    p.xz = fold45(p.xz);
    p.x += off1;
    p -= off;
    p *= scale;
    p += off;
    s *= scale;
  }
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de40.png" alt="fractal_de40", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s=4.;
  p=abs(p);
  vec3 off=p*4.6;
  for (float i=0.; i<8.; i++){
    p=1.-abs(abs(p-2.)-1.); 
    float r=-13.*clamp(.38*max(1.3/dot(p,p),.7),0.,3.3);
    s*=r; p*=r; p+=off;
  }
  return length(cross(p,normalize(vec3(1,3,3))))/s-.006;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de41.png" alt="fractal_de41", height=200px></td>
</tr>


   <!-- fractal_de42 crashes -->
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 rotate(vec3 p,vec3 axis,float theta){
  vec3 v = cross(axis,p), u = cross(v, axis);
  return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   
}

vec2 pmod(vec2 p, float r){
  float a = mod(atan(p.y, p.x), (M_PI*2) / r) - 0.5 * (M_PI*2) / r;
  return length(p) * vec2(-sin(a), cos(a));
}

float de(vec3 p){
  for(int i=0;i<5;i++){
    p.xy = pmod43(p.xy,12.0); p.y-=4.0;
    p.yz = pmod43(p.yz,16.0); p.z-=6.8;
  }
  return dot(abs(p),rotate43(normalize(vec3(2,1,3)),
      normalize(vec3(7,1,2)),1.8))-0.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de43.png" alt="fractal_de43", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define pmod(p,n)length(p)*sin(vec2(0.,M_PI/2.)\
 +mod(atan(p.y,p.x),2.*M_PI/n)-M_PI/n)
#define fold(p,v)p-2.*min(0.,dot(p,v))*v;

float de( vec3 p ){
  float s = 1.0;
  p.z=fract(p.z)-.5;
  for(int i=0;i<20;i++){ // expensive
    p.y += .15;
    p.xz = abs(p.xz);
    for(int j=0;j<2;j++){
      p.xy = pmod(p.xy,8.);
      p.y -= .18;
    }
    p.xy = fold(p.xy,normalize(vec2(1,-.8)));
    p.y = -abs(p.y);
    p.y += .4;
    p.yz = fold(p.yz,normalize(vec2(3,-1)));
    p.x -= .47;
    p.yz = fold(p.yz,normalize(vec2(2,-7)));
    p -= vec3(1.7,.4,0);
    float r2= 3.58/dot(p,p);
    p *= r2;
    p += vec3(1.8,.7,.0);
    s *= r2;
  }
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de44.png" alt="fractal_de44", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.z-=2.5;
  float s = 3.;
  float e = 0.;
  for(int j=0;j++<8;)
    s*=e=3.8/clamp(dot(p,p),0.,2.),
    p=abs(p)*e-vec3(1,15,1);
  return length(cross(p,vec3(1,1,-1)*.577))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de45.png" alt="fractal_de45", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s = 2.;
  float e = 0.;
  for(int j=0;++j<7;)
    p.xz=abs(p.xz)-2.3,
    p.z>p.x?p=p.zyx:p,
    p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),
    p.y>p.x?p=p.yxz:p,
    p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),
    p.y>p.x?p=p.yxz:p,
    p.y=.9-abs(p.y-.4),
    e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+
    2.*clamp(.1/min(dot(p,p),1.),.0,1.),
    p=e*p-vec3(7,1,1),
    s*=e;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de46.png" alt="fractal_de46", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  float s = 4.;
  for(int i = 0; i < 8; i++) {
    p=mod(p-1.,2.)-1.;
    float r2=(i%3==0)?1.5:1.2/dot(p,p);
    p*=r2; s*=r2;
  }
  vec3 q=p/s;
  q.xz=mod(q.xz-.002,.004)-.002;
  return min(length(q.yx)-.0003,length(q.yz)-.0003);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de47.png" alt="fractal_de47", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de( vec3 p ){
  p.z-=-1.;
#define fold(p,v)p-2.*min(0.,dot(p,v))*v;
  float s=3., l=0.;
  for(int i = 0;++i<15;){
    p.xy=fold(p.xy,normalize(vec2(1,-1.3)));
    p.y=-abs(p.y);
    p.y+=.5;
    p.xz=abs(p.xz);
    p.yz=fold(p.yz,normalize(vec2(8,-1)));
    p.x-=.5;
    p.yz=fold(p.yz,normalize(vec2(1,-2)));
    p-=vec3(1.8,.4,.1);
    l = 2.6/dot(p,p);    p*=l;
    p+=vec3(1.8,.7,.2);  s*=l;
  }
  return length(p.xy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de48.png" alt="fractal_de48", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm(vec3 p, float n){
  p = pow(abs(p), vec3(n));
  return pow(p.x+p.y+p.z, 1.0/n);
}

float de(vec3 p){
  float s = 1.;
  for(int i = 0; i < 9; i++) {
    p=p-2.*round(p/2.);
    float r2=1.1/max(pow(lpNorm(p.xyz, 4.5),1.6),.15);
    p*=r2; s*=r2;
  }
  return length(p)/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de49.png" alt="fractal_de49", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float hash(float x){
  return fract(sin(x*234.123+156.2));
}
float lpNorm(vec3 p, float n){
  p = pow(abs(p), vec3(n));
  return pow(p.x+p.y+p.z, 1.0/n);
}
float de(vec3 p){
  vec2 id=floor(p.xz);
  p.xz=mod(p.xz,1.)-.5;
  p.y=abs(p.y)-.5;
  p.y=abs(p.y)-.5;
  p.xy*=rot(hash(dot(id,vec2(12.3,46.7))));
  p.yz*=rot(hash(dot(id,vec2(32.9,76.2))));
  float s = 1.;
  for(int i = 0; i < 6; i++) {
    float r2=1.2/pow(lpNorm(p.xyz, 5.0),1.5);
    p-=.1; p*=r2; s*=r2; p=p-2.*round(p/2.);
  }
  return .6*dot(abs(p),normalize(vec3(1,2,3)))/s-.002;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de50.png" alt="fractal_de50", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  for(int j=0;++j<8;)
    p.z-=.3,
    p.xz=abs(p.xz),
    p.xz=(p.z>p.x)?p.zx:p.xz,
    p.xy=(p.y>p.x)?p.yx:p.xy,
    p.z=1.-abs(p.z-1.),
    p=p*3.-vec3(10,4,2);

  return length(p)/6e3-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de51.png" alt="fractal_de51", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float lpNorm(vec3 p, float n){
  p = pow(abs(p),vec3(n));
  return pow(p.x+p.y+p.z,1./n);
}
float de( vec3 p ){
  float scale=4.5;
  float mr2=.5;
  float off=.5;
  float s=1.;
  vec3 p0 = p;
  for (int i=0; i<16; i++) {
    if(i%3==0)p=p.yzx;
    if(i%2==1)p=p.yxz;
    p -= clamp(p,-1.,1.)*2.;
    float r2=pow(lpNorm(p.xyz,5.),2.);
    float g=clamp(mr2*max(1./r2,1.),0.,1.);
    p=p*scale*g+p0*off;
    s=s*scale*g+off;
  }
  return length(p)/s-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de52.png" alt="fractal_de52", height=200px></td>
</tr>

  <!-- fractal_de53 crashes -->
  <!-- fractal_de54 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  float s=2.;
  float e=0.;
  vec3 q=vec3(3,3,.0);
  for(int i=0; i++<7; p=q-abs(p-q*.4))
    s*=e=15./min(dot(p,p),15.),
    p=abs(p)*e-2.;
  return (length(p.xz)-.5)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de55.png" alt="fractal_de55", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  vec3 q;
  p-=vec3(1.,.1,.1);
  q=p;
  float s=1.5;
  float e=0.;
  for(int j=0;j++<15;s*=e)
    p=sign(p)*(1.2-abs(p-1.2)),
    p=p*(e=8./clamp(dot(p,p),.3,5.5))+q*2.;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de56.png" alt="fractal_de56", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  p.xz=fract(p.xz)-.5;
  float k=1.;
  float s=0.;
  for(int i=0;i++<9;)
    s=2./clamp(dot(p,p),.1,1.),
    p=abs(p)*s-vec3(.5,3,.5),
    k*=s;
  return length(p)/k-.001;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de57.png" alt="fractal_de57", height=200px></td>
</tr>

  <!-- fractal_de58 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  p.xz=fract(p.xz)-.5;
  float k=1.;
  float s=0.;
  for(int i=0;i++<9;)
    s=2./clamp(dot(p,p),.1,1.),
    p=abs(p)*s-vec3(.5,3,.5),
    k*=s;
  return length(p)/k-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de59.png" alt="fractal_de59", height=200px></td>
</tr>





<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float de(vec3 p){
  p=abs(p)-3.;
  if(p.x < p.z)p.xz=p.zx;
  if(p.y < p.z)p.yz=p.zy;
  if(p.x < p.y)p.xy=p.yx;
  float s=2.; vec3 off=p*.5;
  for(int i=0;i<12;i++){
    p=1.-abs(p-1.);
    float k=-1.1*max(1.5/dot(p,p),1.5);
    s*=abs(k); p*=k; p+=off;
    p.zx*=rot(-1.2);
  }
  float a=2.5;
  p-=clamp(p,-a,a);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de61.png" alt="fractal_de61", height=200px></td>
</tr>

  <!-- fractal_de63 crashes -->

<tr><td><code>xem<code></td>    
<td><pre> 
float de(vec3 p){
  vec4 o=vec4(p,1);
  vec4 q=o;
  for(float i=0.;i<9.;i++){
    o.xyz=clamp(o.xyz,-1.,1.)*2.-o.xyz;
    o=o*clamp(max(.25/dot(o.xyz,o.xyz),.25),0.,1.)*vec4(11.2)+q;
  }
  return (length(o.xyz)-1.)/o.w-5e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de66.png" alt="fractal_de66", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  float g=1.;
  float e=0.;
  vec3 q=vec3(0);
  p.z-=1.;
  q=p;
  float s=2.;
  for(int j=0;j++<8;)
    p-=clamp(p,-.9,.9)*2.,
    p=p*(e=3./min(dot(p,p),1.))+q,
    s*=e;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de72.png" alt="fractal_de72", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
  vec3 q;
  p.z-=1.5;
  q=p;
  float e=0.;
  float s=3.;
  for(int j=0;j++<8;s*=e)
    p=sign(p)*(1.-abs(abs(p-2.)-1.)),
    p=p*(e=6./clamp(dot(p,p),.3,3.))+q-vec3(8,.2,8);
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de75.png" alt="fractal_de75", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
float de(vec3 p){
    vec3 q;
    p.z-=1.5;
    q=p;
    float e=0.;
    float s=3.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.-abs(abs(p-2.)-1.)),
        p=p*(e=6./clamp(dot(p,p),.3,3.))+q-vec3(8,.2,8);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de76.png" alt="fractal_de76", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.;
    float l=dot(p,p);
    float e=0.;
    escape=0.;
    p=abs(abs(p)-.7)-.5;
    p.x < p.y?p=p.yxz:p;
    p.y < p.z?p=p.xzy:p;
    for(int i=0;i++<8;){
        s*=e=2./clamp(dot(p,p),.004+tan(12.)*.002,1.35);
        p=abs(p)*e-vec2(.5*l,12.).xxy;
    }
    return length(p-clamp(p,-1.,1.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de78.png" alt="fractal_de78", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=1.5;
    vec3 q=p;
    float s=1.5;
    float e=0.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.2-abs(p-1.2)),
        p=p*(e=8./clamp(dot(p,p),.6,5.5))+q-vec3(.3,8,.3);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de79.png" alt="fractal_de79", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float e=1.,B=2.95,H=.9, s=2.;
    p.z=mod(p.z-2.,4.)-2.;
    for(int j=0;j++<8;)
    {
        p=abs(p);
        p.x < p.z?p=p.zyx:p;
        p.x=H-abs(p.x-H);
        p.y < p.z?p=p.xzy:p;
        p.xz+=.1;
        p.y < p.x?p=p.yxz:p;
        p.y-=.1;
    }
    p*=B; p-=2.5; s*=B;
    return length(p.xy)/s-.007;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de80.png" alt="fractal_de80", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define hash(n) fract(sin(n*234.567+123.34))
  float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   
  p-=clamp(p,-3.5,3.5)*2.;
  float scale=-5.;
  float mr2=.38;
  float off=1.2;
  float s=3.;
  p=abs(p);
  vec3  p0 = p;
  for (float i=0.; i<4.+hash(seed)*6.; i++){
    p=1.-abs(p-1.);
    float g=clamp(mr2*max(1.2/dot(p,p),1.),0.,1.);
    p=p*scale*g+p0*off;
    s=s*abs(scale)*g+off;
  }
  return length(cross(p,normalize(vec3(1))))/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de81.png" alt="fractal_de81", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define hash(n) fract(sin(n*234.567+123.34))
  float zoom=2.1;
  p*=zoom;
  float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   
  p-=clamp(p,-8.,8.)*2.;
  float s=3.*zoom;
  p=abs(p);
  vec3  p0 = p*1.6;
  for (float i=0.; i<10.; i++){
    p=1.-abs(abs(p-2.)-1.); 
    float g=-8.*clamp(.43*max(1.2/dot(p,p),.8),0.,1.3);
    s*=abs(g); p*=g; p+=p0;
  }
  return length(cross(p,normalize(vec3(1))))/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de82.png" alt="fractal_de82", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=16.; float s=3.; float e=0.;
    p.y=abs(p.y)-1.8;
    p=clamp(p,-3.,3.)*2.-p;
    s*=e=6./clamp(dot(p,p),1.5,50.);
    p=abs(p)*e-vec3(0,1.8,0);
    p.xz =.8-abs(p.xz-2.);
    p.y =1.7-abs(p.y-2.);
    s*=e=12./clamp(dot(p,p),1.0,50.);
    p=abs(p)*e-vec2(.2,1).xyx;
    p.y =1.5-abs(p.y-2.);
    s*=e=16./clamp(dot(p,p),.1,9.);
    p=abs(p)*e-vec2(.3,-.7).xyx;
    return min(
            length(p.xz)-.5,
            length(vec2(length(p.xz)-12.,p.y))-3.
            )/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de84.png" alt="fractal_de84", height=200px></td>
</tr>



<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
  vec4 p = vec4(p0/10., 1.);
  escape = 0.; p=abs(p);
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z > p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p*=(1.3/clamp(dot(p.xyz,p.xyz),0.1,1.));
    p.xyz-=vec3(.5,0.2,0.2);
  }
  float m = 1.5;
  p.xyz-=clamp(p.xyz,-m,m);
  return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de86.png" alt="fractal_de86", height=200px></td>
</tr>


<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
    vec4 p = vec4(p0/10., 1.);
    escape = 0.; p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 6; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p = abs(p);
        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.1,1.));
        p.xyz-=vec3(0.2,1.9,0.6);
    }
    float m = 1.2;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de87.png" alt="fractal_de87", height=200px></td>
</tr>



<tr><td><code>Nameless<code></td>
<td><pre> 
float de(vec3 p0){
    vec4 p = vec4(p0/10., 1.);
    escape = 0.; p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 6; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p = abs(p);
        p*=(2./clamp(dot(p.xyz,p.xyz),0.1,1.));
        p.xyz-=vec3(0.9,1.9,0.9);
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de88.png" alt="fractal_de88", height=200px></td>
</tr>


<tr><td><code>Ivan Dianov<code></td>
<td><pre> 
float de(vec3 p){
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
  p.z-=.25;
  float j=0.,c=0.,s=1.;
  p.y = fract(p.y)-.5;
  for(;j<10.;j++){
    p=abs(p);
    p-=vec2(.05,.5).xyx;
    p.xz*=rot(1.6);
    p.yx*=rot(.24);
    p*=2.; s*=2.;
  }
  return (length(p)-1.)/s*.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de89.png" alt="fractal_de89", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  float j = 0.5;
  for(p.xz=mod(p.xz,6.)-3.;++j<9.;p=3.*p-.9)
    p.xz=abs(p.xz),
    p.z>p.x?p=p.zyx:p,
    p.y>p.z?p=p.xzy:p,
    p.z--,
    p.x-=++p.y*.5;
  return min(.2,p.x/4e3-.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de90.png" alt="fractal_de90", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=4.;
  float l=0;
  p.z-=.9;
  vec3 q=p;
  s=2.;
  for(int j=0;j++<9;)
    p-=clamp(p,-1.,1.)*2.,
    p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,
    s*=l;
  return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de91.png" alt="fractal_de91", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=3., l=0.;
  vec3 q=p;
  p=mod(p,4.)-2.;
  p=abs(p);
  for(int j=0;j++<8;)
    p=1.-abs(p-1.),
    p=p*(l=-1.*max(1./dot(p,p),1.))+.5,
    s*=l;
  return max(.2-length(q.xy),length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de92.png" alt="fractal_de92", height=200px></td>
</tr>


<tr><td><code>eiffie<code></td>
<td><pre> 
float de(vec3 p){
  const int iters=5;
  const int iter2=3;
  const float scale=3.48;
  const vec3 offset=vec3(1.9,0.0,2.56);
  const float psni=pow(scale,-float(iters));
  const float psni2=pow(scale,-float(iter2));
  p = abs(mod(p+3., 12.)-6.)-3.;
  vec3 p2;
  for (int n = 0; n < iters; n++) {
    if(n==iter2)p2=p;
    p = abs(p);
    if (p.x < p.y)p.xy = p.yx;
    p.xz = p.zx;
    p = p*scale - offset*(scale-1.0);
    if(p.z<-0.5*offset.z*(scale-1.0))
    p.z+=offset.z*(scale-1.0);
  }
  float d1=(length(p.xy)-1.0)*psni;
  float d2=length(max(abs(p2)-vec3(0.2,5.1,1.3),0.0))*psni2;
  escape=(d1 < d2)?0.:1.;
  return min(d1,d2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de93.png" alt="fractal_de93", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  p=fract(p)-.5;
  vec3 O=vec3(2.,0,3.);
  for(int j=0;j++<7;){
    p=abs(p);
    p=(p.x < p.y?p.zxy:p.zyx)*3.-O;
    if(p.z < -.5*O.z)
    p.z+=O.z;
  } 
  return length(p.xy)/3e3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de94.png" alt="fractal_de94", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre>
float de(vec3 p){
  p=fract(p)-.5;
  vec3 O=vec3(2.,0,5.);
  for(int j=0;j++<7;){
    p=abs(p);
    p=(p.x < p.y?p.zxy:p.zyx)*3.-O;
    if(p.z < -.5*O.z)
    p.z+=O.z;
  } 
  return length(p.xy)/3e3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de95.png" alt="fractal_de95", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.; p = abs(p);
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de96.png" alt="fractal_de96", height=200px></td>
</tr>



<tr><td><code>variant of code by gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.;
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de97.png" alt="fractal_de97", height=200px></td>
</tr>



<tr><td><code>variant of code by gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  vec3 a=vec3(.5);
  p.z-=55.;
  float s=2., l=0.;
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-2.12/max(.2,dot(p,p)),
    p=p*l-.55;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de98.png" alt="fractal_de98", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float i,g,e=1.,s=2.,l;
  vec3 a=vec3(.5);
  p.z-=55.; p=abs(p);
  for(int j=0;j++<8;)
    p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
    s*=l=-1.55/max(.4,dot(p,p)),
    p=p*l-.535;
  return dot(p,a)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de99.png" alt="fractal_de99", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;vec3 q;
    q=p*2.;
    R=7.;
    for(int j=0;j++<9;){
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.);
        S=-9.*clamp(.7/min(dot(p,p),3.),0.,1.);
        p=p*S+q; R=R*abs(S);
    }
    return length(p)/R; 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de100.png" alt="fractal_de100", height=200px></td>
</tr>





<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
void rot101(inout vec3 p,vec3 a,float t){
	a=normalize(a);
	vec3 u=cross(a,p),v=cross(a,u);
	p=u*sin(t)+v*cos(t)+a*dot(a,p);   
}
#define G dot(p,vec2(1,-1)*.707)
#define V v=vec2(1,-1)*.707
void sfold101(inout vec2 p){
    vec2 v=vec2(1,-1)*.707;
    float g=dot(p,v);
    p-=(G-sqrt(G*G+.01))*v;
}
float de(vec3 p){
    float k=.01;
    for(int i=0;i<8;i++){
        p=abs(p)-1.;
        sfold101(p.xz);
        sfold101(p.yz);
        sfold101(p.xy);
        rot101(p,vec3(1,2,2),.6);
        p*=2.;
    }
    return length(p.xy)/exp2(8.)-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de101.png" alt="fractal_de101", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    #define V vec2(.7,-.7)
    #define G(p)dot(p,V)
    float i=0.,g=0.,e=1.;
    float t = 0.34; // change to see different behavior
    for(int j=0;j++<8;){
        p=abs(rotate3D(0.34,vec3(1,-3,5))*p*2.)-1.,
        p.xz-=(G(p.xz)-sqrt(G(p.xz)*G(p.xz)+.05))*V;
    }
    return length(p.xz)/3e2;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de102.png" alt="fractal_de102", height=200px></td>
</tr>




<tr><td><code>Kali<code></td>
<td><pre> 
float de(vec3 p) {
  const float width=.22;
  const float scale=4.;
  float t=0.2;
  float dotp=dot(p,p);
  p.x+=sin(t*40.)*.007;
  p=p/dotp*scale;
  p=sin(p+vec3(sin(1.+t)*2.,-t,-t*2.));
  float d=length(p.yz)-width;
  d=min(d,length(p.xz)-width);
  d=min(d,length(p.xy)-width);
  d=min(d,length(p*p*p)-width*.3);
  return d*dotp/scale;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de103.png" alt="fractal_de103", height=200px></td>
</tr>

<!-- fractal_de104 crashes -->
<!-- fractal_de105 isn't a valid distance bound -->

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,a,n,h,d=1.,t=0.3; // change t for different behavior
    vec3 q;
    n=.4;
    for(a=1.;a<2e2;n+=q.x*q.y*q.z/a)
        p.xy*=rotate2D(a+=a),
        q=cos(p*a+t);
    return n*.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de106.png" alt="fractal_de106", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    vec3 z,q;
    p.z -= 9.; z=p;
    float a=1.,n=.9;
    for(int j=0;j++<15;){
        p.xy*=rotate2D(float(j*j));
        a*=.66;
        q=sin(p*=1.5);
        n+=q.x*q.y*q.z*a;
    }
    return (n*.2-z.z*.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de107.png" alt="fractal_de107", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
      vec3 q;
      float s=1., a=1., n=.5;
      for(int j=0;j++<9;){
          p.xy*=rotate2D(float(j*j));
          a*=.5; q=sin(p+=p);
          n+=q.x*q.y*q.z*a;
      }
      return n*.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de108.png" alt="fractal_de108", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float h,d=1.,i,u,s, t = 0.8; // vary t for different behavior
    p+=vec3(1,1,sin(t/4.)*3.);
    s=2.;
    for(int j=0;j<9;j++){
        p.xy*=rotate2D(t/4.);
        u=4./3./dot(p,p);
        s*=u;
        p=mod(1.-p*u,2.)-1.;
    }
    return (length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de109.png" alt="fractal_de109", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,d=1.,s,h;
    vec3 e,q;
    s=2.;h=.3;
    for(int j=0;j++<8;){
        p=abs(p)-1.; q=p;
        for(int k=0;++k<3;)
            p-=clamp(dot(q,e=vec3(9>>k&1,k>>1&1,k&1)-.5),-h,h)*e*2.;
        p*=1.4;s*=1.4;
    }
    return length(p)/(4.*s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de110.png" alt="fractal_de110", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float  de(vec3 p){
    float i,g,e=1.,s,l;
    p.z-=9.; s=2.;
    p=abs(p);
    for(int j=0;j++<6;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-2./max(.3,sqrt(min(min(p.x,p.y),p.z))),
        p-=2., s*=l;
    return length(p)/s;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de111.png" alt="fractal_de111", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s;
    vec3 q=p; s=5.;
    for(int j=0;j++<6;s*=e)
        p=sign(p)*(1.7-abs(p-1.7)),
        p=p*(e=8./clamp(dot(p,p),.3,5.))+q-vec3(.8,12,.8);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de112.png" alt="fractal_de112", height=200px></td>
</tr>




<tr><td><code>adapted from code by catzpaw<code></td>
<td><pre> 
float de(vec3 p){
    float k = M_PI*2.;
    vec3 v = vec3(0.,3.,fract(k));
    return (length(cross(p=cos(p+v),p.zxy))-0.1)*0.4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de113.png" alt="fractal_de113", height=200px></td>
</tr>




<tr><td><code>adapted from code by catzpaw<code></td>
<td><pre> 
float de(vec3 p){
    float k = M_PI*2.;
    vec3 v = vec3(0.,3.,fract(k));
    return (length(cross(cos(p+v),p.zxy))-0.4)*0.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de114.png" alt="fractal_de114", height=200px></td>
</tr>




<tr><td><code>catzpaw<code></td>
<td><pre> 
float de(vec3 p){  (distance bound doesn't hold)
    vec3 v=vec3(0,1.5,6.3);
    return min(6.-length((p-v).xy+sin(p.yx)), 
      dot(cos(p),sin(p.yzx)))+sin(sin(p.z*3.5)+v.z)*.1+1.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de115.png" alt="fractal_de115", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=80.; p=abs(p);
    float s=3., l=0.;
    for(int j=0;j++<8;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-.8/min(2.,length(p)),
        p-=.5, s*=l;
    return (length(p)/s)-0.1;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de116.png" alt="fractal_de116", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s = 1.;
    for(int j=0;j<7;j++)
        p=mod(p-1.,2.)-1.,
        p*=1.2, s*=1.2,
        p=abs(abs(p)-1.)-1.;
    return (length(cross(p,normalize(vec3(2,2.03,1))))/s)-0.02;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de117.png" alt="fractal_de117", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., l=0.;
    p=abs(p);
    for(int j=0;j++<8;)
        p=1.-abs(abs(p-2.)-1.),
        p*=l=1.2/dot(p,p), s*=l;
    return dot(p,normalize(vec3(3,-2,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de118.png" alt="fractal_de118", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., l=0.;
    p=abs(p);
    for(int j=0;j++<8;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-1.3/dot(p,p),
        p-=.15, s*=l;
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de119.png" alt="fractal_de119", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.z-=20;
    float s=3., l=0.;
    p=abs(p);
    for(int j=0;j++<10;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        p*=l=-1./max(.19,dot(p,p)),
        p-=.24, s*=l;
    return (length(p)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de120.png" alt="fractal_de120", height=200px></td>
</tr>




<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
      float s=2., l=0.;
      p=abs(mod(p-1.,2.)-1.);
      for(int j=0;j++<8;)
          p=1.-abs(abs(abs(p-5.)-2.)-2.),
          p*=l=-1.3/dot(p,p),
          p-=vec3(.3,.3,.4), s*=l;
      return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de121.png" alt="fractal_de121", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e=1.,R,S;
    vec3 q=p*8.; R=8.;
    for(int j=0;j++<6;)
        p=-sign(p)*(abs(abs(abs(p)-2.)-1.)-1.),
        S=-5.*clamp(1.5/dot(p,p),.8,5.),
        p=p*S+q, R*=S;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de122.png" alt="fractal_de122", height=200px></td>
</tr>

<!-- fractal_de123 crashes -->

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre>
float de(vec3 p){
    float i,g,e,s=2.,k;
    vec3 q;
    p=vec3(length(p.xy)-PI,atan(p.y,p.x)*PI,p.z);
    p.yz=mod(p.yz,4.)-2.;
    p=abs(p); q=p;
    for(int j=0;++j<5;)
        p=1.-abs(p-1.),
        p=-p*(k=max(3./dot(p,p),3.))+q, s*=k;
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de124.png" alt="fractal_de124", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R=2.,S;
    for(int j=0;j++<9;)
        p=1.-abs(p-1.),
        p*=S=(j%3>1)?1.3:1.2/dot(p,p),
        R*=S;
    return length(cross(p,vec3(.5)))/R-5e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de125.png" alt="fractal_de125", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
  float s=2.,r2;
  p=abs(p);
  for(int i=0; i<12;i++){
    p=1.-abs(p-1.);
    r2=(i%3==1)?1.1:1.2/dot(p,p);
    p*=r2; s*=r2;
  }
  return length(cross(p,normalize(vec3(1))))/s-0.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de126.png" alt="fractal_de126", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=3.,l;
    vec3 q=p;
    for(int j=0;j++<9;)
        p=mod(p-1.,2.)-1.,
        l=1.2/pow(pow(dot(pow(abs(p),vec3(5)),vec3(1)),.2),1.6),
        p*=l, s*=l;
    return abs(p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de127.png" alt="fractal_de127", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=4.,l;
    vec3 q=p;
    for(int j=0;j++<9;)
        p=mod(p-1.,2.)-1.,
        l=1.2/dot(p,p),
        p*=l, s*=l;
    return abs(p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de128.png" alt="fractal_de128", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s=1.,l;
    vec3 q=p;
    for(int j=0;j++<4;)
        p=mod(p-1.,2.)-1.,
        l=2./dot(p,p),
        p*=l, s*=l;
    return length(p.xy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de129.png" alt="fractal_de129", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define F1(s)p.s=abs(p.s)-1.
    p+=vec3(0,3.8,5.);
    vec3 q=p;
    p=mod(p,vec3(8,8,2))-vec3(4,4,1);
    F1(yx); F1(yx); F1(xz);
    return min(length(cross(p,vec3(.5)))-.03,length(p.xy)-.05);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de130.png" alt="fractal_de130", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float l,s=3.;
    float t = 4.5;
    for(int j=0;j++<5;p.xy=fract(p.xy+p.x)-.5)
        p=vec3(log(l=length(p.xy)),atan(p.y,p.x)/PI*2.,p.z/l+1.),
        s*=.5*l;
    return abs(p.z)*s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de131.png" alt="fractal_de131", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q=p; R=2.;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=9.*clamp(.7/min(dot(p,p),3.),0.,1.),
        p=p*S+q,
        R=R*abs(S)+1.,
        p=p.yzx;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de133.png" alt="fractal_de133", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R=1.,S;
    vec3 q=p;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=6.*clamp(.2/min(dot(p,p),7.),0.,1.),
        p=p*S+q*.7,  R=R*abs(S)+.7;
    return length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de134.png" alt="fractal_de134", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q;
    p.z-=3.;
    q=p; R=1.;
    for(int j=0;j++<9;)
        p-=clamp(p,-.9,.9)*2.,
        S=9.*clamp(.1/min(dot(p,p),1.),0.,1.),
        p=p*S+q, R=R*S+1.;
    return .7*length(p)/R;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de135.png" alt="fractal_de135", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,R,S;
    vec3 q;
    p.z-=4.;
    q=p; R=1.;
    for(int j=0;j++<9;)
        p-=clamp(p,-1.,1.)*2.,
        S=9.*clamp(.3/min(dot(p,p),1.),0.,1.),
        p=p*S+q*.5,
        R=R*abs(S)+.5;
    return .6*length(p)/R-1e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de136.png" alt="fractal_de136", height=200px></td>
</tr>


<tr><td><code>takusakuw<code></td>
<td><pre> 
float de(vec3 p){
    return length(sin(p)+cos(p*.5))-.4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de137.png" alt="fractal_de137", height=200px></td>
</tr>


<tr><td><code>yosshin<code></td>
<td><pre> 
float de(vec3 p){
    return min(.65-length(fract(p+.5)-.5),p.y+.2);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de138.png" alt="fractal_de138", height=200px></td>
</tr>


<tr><td><code>takusakuw<code></td>
<td><pre> 
float de(vec3 p){
    return (length(sin(p.zxy)-cos(p.zzx))-.5);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de139.png" alt="fractal_de139", height=200px></td>
</tr>


<tr><td><code>yuruyurau<code></td>
<td><pre> 
float de(vec3 p){
#define b(p)length(max(abs(mod(p,.8)-.4)-.05,0.))
    vec3 l;
    p=cos(p)-vec3(.3), p.yx*=mat2(cos(.8+vec4(0,3,5,0)));
    return min(min(b(p.xy),b(p.xz)),b(p.yz));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de140.png" alt="fractal_de140", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    #define F1(a,n)a=abs(a)-n,a=vec2(a.x*.5+a.y,a.x-a.y*.5)
    p=fract(p)-.5;
    for(int j=0;j++<8;)
      F1(p.zy,.0),
      F1(p.xz,.55);
    return .4*length(p.yz)-2e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de141.png" alt="fractal_de141", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define M(a)mat2(cos(a+vec4(0,2,5,0)))
#define F1(a)for(int j=0;j<5;j++)p.a=abs(p.a*M(3.));(p.a).y-=3.
    float t = 0.96;
    p.z-=9.;
    p.xz*=M(t);
    F1(xy);
    F1(zy);
    return dot(abs(p),vec3(.3))-.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de142.png" alt="fractal_de142", height=200px></td>
</tr>


<tr><td><code>adapted from code by alia<code></td>
<td><pre> 
float de(vec3 p){
    vec3 q=fract(p)-.5;
    float f=-length(p.xy)+2., g=length(q)-.6;
    return max(f,-g);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de143.png" alt="fractal_de143", height=200px></td>
</tr>


<tr><td><code> adapted from code by wrighter - aliasing issues<code></td>
<td><pre> 
float de(vec3 p){
   vec3 a = sin(p/dot(p,p)*4);
   return 0.95*min(length(a.yx),length(a.yz))-0.52+0.2;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de144.png" alt="fractal_de144", height=200px></td>
</tr>


<tr><td><code>phi16<code></td>
<td><pre> 
float de(vec3 p){ 
    return length(.05*cos(9.*p.y*p.x)+cos(p)-.1*cos(9.*(p.z+.3*p.x-p.y)))-1.; 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de145.png" alt="fractal_de145", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    vec3 q=p;
    float s=5., e=0.;
    for(int j=0;j++<8;s*=e)
        p=sign(p)*(1.-abs(abs(p-2.)-1.)),
        p=p*(e=6./clamp(dot(p,p),.1,3.))-q*vec3(2,8,5);
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de146.png" alt="fractal_de146", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float e=2., s=0., z=0.;
    for(int j=0;++j<6;p=abs(p)-1.5,e/=s=min(dot(p,p),.75),p/=s);
    z+=length(p.xz)/e;
    return z;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de147.png" alt="fractal_de147", height=200px></td>
</tr>

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,j,e,g,h,s;
    p.y-=p.z*.5;
    for(j=s=h=.01;j++<9.;s+=s)
        p.xz*=rotate2D(2.),
        h+=abs(sin(p.x*s)*sin(p.z*s))/s;
    return max(0.,p.y+h);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de148.png" alt="fractal_de148", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float i,g,e,s,q;
    q=length(p)-1.;
    p.y++;
    s=3.;
    for(int i=0;i++<7;p=vec3(0,5,0)-abs(abs(p)*e-3.))
        s*=e=max(1.,14./dot(p,p));
    return max(q,min(1.,length(p.xz)-.3))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de149.png" alt="fractal_de149", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e=0.;
    for(int i=0;i++<8;p=abs(p)*e)
        p=vec3(.8,2,1)-abs(p-vec3(1,2,1)),
        s*=e=1.3/clamp(dot(p,p),.1,1.2);
    return min(length(p.xz),p.y)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de150.png" alt="fractal_de150", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float i,g=.3,e,s=2.,q;
    for(int i=0;i++<7;p=vec3(2,5,1)-abs(abs(abs(p)*e-3.)-vec3(2,5,1)))
        s*=e=12./min(dot(p,p),12.);
    return min(1.,length(p.xz)-.2)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de151.png" alt="fractal_de151", height=200px></td>
</tr>


<tr><td><code>kamoshika<code></td>
<td><pre> 
float de(vec3 p){
    vec3 Q;
    float i,d=1.,a,b=sqrt(3.);
    Q=mod(p,b*2.)-b;
    a=1.; d=9.;
    for(int j=0;j++<7;){
        Q=abs(Q);
        d=min(d,(dot(Q,vec3(1)/b)-1.)/a);
        Q=Q*3.-6./b;a*=3.;
    }
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de152.png" alt="fractal_de152", height=200px></td>
</tr>


<tr><td><code>kamoshika<code></td>
<td><pre> 
float de(vec3 p){
    float i,d=1.,b=1.73;
    vec3 Q=mod(p,b*2.)-b;
    for(int j=0;j++<6;){
        Q=abs(Q);
        if(Q.y>Q.x)Q.xy=Q.yx;
        if(Q.z>Q.x)Q.zx=Q.xz;
        Q*=2.;
        Q.x-=b;
    }
    return (dot(abs(Q),vec3(1)/b)-1.)/64.;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de153.png" alt="fractal_de153", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
  return (length(vec2((length(vec2(length(p.xy)-1.3,
    length(p.zy)-1.3))-.5), dot(cos(p*12.),sin(p.zxy*12.))*.1))-.02)*.3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de154.png" alt="fractal_de154", height=200px></td>
</tr>


<!-- fractal_de155 crashes -->



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
      p.yz*=rotate2D(-.3);
      float ss=3., s=1.;
      for(int j=0; j++<7;){
          p=abs(p); p.y-=.5;
          s = 1./clamp(dot(p,p),.0,1.);
          p*=s; ss*=s;
          p-=vec2(1,.1).xxy;
          p.xyz=p.zxy;
      }
      return length(p.xy)/ss-.01;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de156.png" alt="fractal_de156", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.yz*=rotate2D(-.3);
    float ss=3., s=1.;
    for(int j=0; j++<7;){
        p=abs(p); p.y-=.5;
        s = 1./clamp(dot(p,p),.0,1.);
        p*=s; ss*=s;
        p-=vec2(1,.1).xxy;
        p.xyz=p.zxy;
    }
    return length(max(abs(p)-.6,0.))/ss-.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de157.png" alt="fractal_de157", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<8;){
        p=.1-abs(p-.2);
        p.x < p.z?p=p.zyx:p;
        s*=e=1.6;
        p=abs(p)*e-vec3(.1,3,1);
        p.yz*=rotate2D(.8);
    }
    return length(p.yx)/s-.04;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de158.png" alt="fractal_de158", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<8;){
        p=.5-abs(p);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=1.6;
        p=abs(p)*e-vec3(.5,30,5);
        p.yz*=rotate2D(.3);
    }
    return length(p.xy)/s-.005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de159.png" alt="fractal_de159", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3.,e;
    for(int i=0;i++<3;p=vec3(2,4,2)-abs(abs(p)*e-vec3(3,6,1)))
        s*=e=1./min(dot(p,p),.6);
    return min(length(p.xz),abs(p.y))/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de160.png" alt="fractal_de160", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    s*=e=3./min(dot(p,p),50.);
    p=abs(p)*e;
    for(int i=0;i++<5;)
        p=vec3(2,4,2)-abs(p-vec3(4,4,2)),
            s*=e=8./min(dot(p,p),9.),
            p=abs(p)*e;
    return min(length(p.xz)-.1,p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de161.png" alt="fractal_de161", height=200px></td>
</tr>




<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., offset=8., e;
    for(int i=0;i++<9;p=vec3(2,4,2)-abs(abs(p)*e-vec3(4,4,2)))
        s*=e=max(1.,(8.+offset)/dot(p,p));
    return min(length(p.xz),p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de162.png" alt="fractal_de162", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=sin(2.8*p+5.*sin(p*.3));
    float s=2., e;
    for(int i=0;i++<6;)
        p=abs(p-1.7)-1.5,
        s*=e=2.3/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e;
    return length(p.zy)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de163.png" alt="fractal_de163", height=200px></td>
</tr>



<tr><td><code>nameless<code></td>
<td><pre> 
float de(vec3 p0){
    p0=p0/10.;
    p0 = mod(p0, 2.)-1.;
    vec4 p = vec4(p0, 1.);
    p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 8; i++){
        if(p.x < p.z)p.xz = p.zx;
        if(p.z < p.y)p.zy = p.yz;
        if(p.y < p.x)p.yx = p.xy;
        p.xyz = abs(p.xyz);
        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.6,1.));
        p.xyz-=vec3(0.7,1.8,0.5);
        p*=1.2;
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de164.png" alt="fractal_de164", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=5., e;
    p=p/dot(p,p)+1.;
    for(int i=0;i++<8;p*=e)
        p=1.-abs(p-1.),
        s*=e=1.6/min(dot(p,p),1.5);
    return length(cross(p,normalize(vec3(1))))/s-5e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de165.png" alt="fractal_de165", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e, offset = 1.; //offset can be adjusted 
    for(int i=0;i++<8;p*=e)
        p=abs(p-vec3(1,3,1.5+offset*.3))-vec3(1,3.+offset*.3,2),
        p*=-1., s*=e=7./clamp(dot(p,p),.7,7.);
    return (p.z)/s+1e-3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de166.png" alt="fractal_de166", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=sin(p+3.*sin(p*.5));
    float s=2., e;
    for(int i=0;i++<5;)
        p=abs(p-1.7)-1.3,
        s*=e=2./min(dot(p,p),1.5),
        p=abs(p)*e-1.;
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de167.png" alt="fractal_de167", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
#define M(p)p=vec2(sin(atan(p.x,p.y)*4.)/3.,1)*length(p),p.y-=2.
    float i,g,e,s;
    for(s=3.;s<4e4;s*=3.)
        M(p.xy),
        M(p.zy),
        p*=3.;
    return length(p.xy)/s-.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de168.png" alt="fractal_de168", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p=1.-abs(abs(p+sin(p))-1.);
    p=p.x < p.y?p.zxy:p.zyx;
    float s=5., l;
    for(int j=0;j++<4;)
        s*=l=2./min(dot(p,p),1.5),
        p=abs(p)*l-vec3(2,1,3);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de169.png" alt="fractal_de169", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    for(int j=0;++j<5;)
        s*=e=1./min(dot(p,p),1.),
        p=abs(p)*e-1.5;
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de170.png" alt="fractal_de170", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.2,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return length(cross(p,vec3(1,1,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de171.png" alt="fractal_de171", height=200px></td>
</tr>

<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=mod(p.xz,2.)-1.;
    vec3 q=p;
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.5,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return max(q.y,length(p.xz)/s);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de172.png" alt="fractal_de172", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=abs(p.xz)-1.;
    p.x>p.z?p=p.zyx:p;
    float s=2., e;
    for(int j=0;j++<7;)
        s*=e=2.2/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e-vec3(1,8,.03);
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de173.png" alt="fractal_de173", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;j++<7;)
        s*=e=2.2/clamp(dot(p,p),.3,1.2),
        p=abs(p)*e-vec3(1,8,1);
    return length(cross(p,vec3(1,1,-1)))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de174.png" alt="fractal_de174", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=mod(p.xz,2.)-1.;
    float s=2., e;
    for(int j=0;j++<8;)
        s*=e=2./clamp(dot(p,p),.5,1.),
        p=abs(p)*e-vec3(.5,8,.5);
    return length(p.xz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de175.png" alt="fractal_de175", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.,e;
    for(int i=0;i<9;i++){
        p=.5-abs(p-.5);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=2.4;
        p=abs(p)*e-vec3(.1,13,5);
    }
    return length(p)/s-0.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de176.png" alt="fractal_de176", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<7;){
        p.xz=.8-abs(p.xz);
        p.x < p.z?p=p.zyx:p;
        s*=e=2.1/min(dot(p,p),1.);
        p=abs(p)*e-vec3(1,18,9);
    }
    return length(p)/s-0.01;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de177.png" alt="fractal_de177", height=200px></td>
</tr>


<tr><td><code>yonatan<code></td>
<td><pre> 
float de(vec3 p){
    float n=1.+snoise3D(p), s=4., e;
    for(int i=0;i++<7;p.y-=20.*n)
        p.xz=.8-abs(p.xz),
        p.x < p.z?p=p.zyx:p,
        s*=e=2.1/min(dot(p,p),1.),
        p=abs(p)*e-n;
    return length(p)/s+1e-4;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de179.png" alt="fractal_de179", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    for(int i=0;i++<8;)
        p=mod(p-1.,2.)-1.,
        s*=e=1.4/dot(p,p),
        p*=e;
    return length(p.yz)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de180.png" alt="fractal_de180", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=4., e;
    for(int i=0;i++<7;p.y-=10.)
        p.xz=.8-abs(p.xz),
        p.x < p.z?p=p.zyx:p,
        s*=e=2.5/clamp(dot(p,p),.1,1.2),
        p=abs(p)*e-1.;
    return length(p)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de181.png" alt="fractal_de181", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int i=0;i++<10;){
        p=.3-abs(p-.8);
        p.x < p.z?p=p.zyx:p;
        p.z < p.y?p=p.xzy:p;
        s*=e=1.7;
        p=abs(p)*e-vec3(1,50,5);
    }
    return length(p.xy)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de182.png" alt="fractal_de182", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=1., e, offset=0.26; // vary between 0 and 1
    for(int i=0;i++<5;){
        s*=e=2./min(dot(p,p),1.);
        p=abs(p)*e-vec3(1,10.*offset,1);
    }
    return length(max(abs(p)-1.,0.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de183.png" alt="fractal_de183", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2.5, e;
    p=abs(mod(p-1.,2.)-1.)-1.;
    for(int j=0;j++<10;)
        p=1.-abs(p-1.),
        s*=e=-1.8/dot(p,p),
        p=p*e-.7;
    return abs(p.z)/s+.001;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de184.png" alt="fractal_de184", height=200px></td>
</tr>



<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<8;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de185.png" alt="fractal_de185", height=200px></td>
</tr>


<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<8;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p-clamp(p,-2.,2.))/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de186.png" alt="fractal_de186", height=200px></td>
</tr>

<tr><td><code>gaziya5 aka gaz<code></td>
<td><pre> 
float de(vec3 p){
    float s=2., e;
    for(int j=0;++j<18;s*=e=2./clamp(dot(p,p),.4,1.),p=abs(p)*e-vec3(2,1,.7));
    return length(p)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de187.png" alt="fractal_de187", height=200px></td>
</tr>

<tr><td><code>amini<code></td>
<td><pre> 
float de(vec3 p){
    float s=3., e;
    s*=e=3./min(dot(p,p),50.);
    p=abs(p)*e;
    for(int i=0;i++<5;)
        p=vec3(8,4,2)-abs(p-vec3(8,4,2)),
        s*=e=8./min(dot(p,p),9.),
        p=abs(p)*e;
    return min(length(p.xz)-.1,p.y)/s;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de188.png" alt="fractal_de188", height=200px></td>
</tr>

<!-- fractal_de190 isn't a valid distance bound -->

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 p){
    p.x = abs(p.x) - 3.3;
    p.z = mod(p.z + 2.0, 4.0) -  2.0;
    vec4 q = vec4(p, 1);
    q.xyz -= 1.0;
    q.xyz = q.zxy;
    for(int i = 0; i < 6; i++) {
        q.xyz = abs(q.xyz + 1.0) - 1.0;
        q /= clamp(dot(q.xyz, q.xyz), 0.25, 1.0);
        q *= 1.1;
        float s = sin(-0.35);
        float c = cos(-0.35);
        q.xy = mat2(c,s,-s,c)*q.xy;
    }
    return (length(q.xyz) - 1.5)/q.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de191.png" alt="fractal_de191", height=200px></td>
</tr>

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 p){
    p.xz=abs(.5-mod(p.xz,1.))+.01;
    float DEfactor=1.;
    for (int i=0; i<14; i++) {
        p = abs(p)-vec3(0.,2.,0.);  
        float r2 = dot(p, p);
        float sc=2./clamp(r2,0.4,1.);
        p*=sc; 
        DEfactor*=sc;
        p = p - vec3(0.5,1.,0.5);
    }
    return length(p)/DEfactor-.0005;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de192.png" alt="fractal_de192", height=200px></td>
</tr>

<tr><td><code>kali<code></td>
<td><pre> 
float de(vec3 pos){
    vec3 tpos=pos;
    tpos.xz=abs(.5-mod(tpos.xz,1.));
    vec4 p=vec4(tpos,1.);
    float y=max(0.,.35-abs(pos.y-3.35))/.35;
    for (int i=0; i<7; i++) {
        p.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);
        p=p*(2.0+0.*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);
        p.xz*=mat2(-0.416,-0.91,0.91,-0.416);
    }
    return (length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de193.png" alt="fractal_de193", height=200px></td>
</tr>

<tr><td><code>shane<code></td>
<td><pre> 
float de(vec3 p){
    const vec3 offs = vec3(1, .75, .5); // Offset point.
    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);
    const mat2 m = mat2(a.y, -a.x, a);
    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);
    const mat2 m2 = mat2(a2.y, -a2.x, a2);
    const float s = 5.; // Scale factor.
    float d = 1e5; // Distance.
    p  = abs(fract(p*.5)*2. - 1.);
    float amp = 1./s;
    for(int i=0; i<2; i++){
        p.xy = m*p.xy;
        p.yz = m2*p.yz;
        p = abs(p);
        p.xy += step(p.x, p.y)*(p.yx - p.xy);
        p.xz += step(p.x, p.z)*(p.zx - p.xz);
        p.yz += step(p.y, p.z)*(p.zy - p.yz);
        p = p*s + offs*(1. - s);
        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);
        p=abs(p);
        d = min(d, max(max(p.x, p.y), p.z)*amp);
        amp /= s;
    }
    return d - .035;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de194.png" alt="fractal_de194", height=200px></td>
</tr>

<tr><td><code>avi<code></td>
<td><pre> 
float de(vec3 p) {
    const vec3 va = vec3(  0.0,  0.57735,  0.0 );
    const vec3 vb = vec3(  0.0, -1.0,  1.15470 );
    const vec3 vc = vec3(  1.0, -1.0, -0.57735 );
    const vec3 vd = vec3( -1.0, -1.0, -0.57735 );
    float a = 0.0;
    float s = 1.0;
    float r = 1.0;
    float dm;
    vec3 v;
    for(int i=0; i<16; i++) {
        float d, t;
        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;
        d = dot(p-vb,p-vb); if( d < dm ) { v=vb; dm=d; t=1.0; }
        d = dot(p-vc,p-vc); if( d < dm ) { v=vc; dm=d; t=2.0; }
        d = dot(p-vd,p-vd); if( d < dm ) { v=vd; dm=d; t=3.0; }
        p = v + 2.0*(p - v); r*= 2.0;
        a = t + 4.0*a; s*= 4.0;
    }
    return (sqrt(dm)-1.0)/r;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de195.png" alt="fractal_de195", height=200px></td>
</tr>

<tr><td><code>guil<code></td>
<td><pre> 
vec3 foldY(vec3 P, float c){
  float r = length(P.xz);
  float a = atan(P.z, P.x);
  a = mod(a, 2.0 * c) - c; 
  P.x = r * cos(a);
  P.z = r * sin(a);
  return P;
}

float de(vec3 p){ 
  float l= length(p)-1.;
  float dr = 1.0, g = 1.25;
  vec4 ot=vec4(.3,.5,0.21,1.);
  ot = vec4(1.);
  mat3 tr = rotate3D(-0.55, normalize(vec3(-1., -1., -0.5)));

  for(int i=0;i<15;i++) {
    if(i-(i/3)*5==0)
    p = foldY(p, .95);
    p.yz = abs(p.yz);				
    p = tr * p * g -1.;		
    dr *= g;
    ot=min(ot,vec4(abs(p),dot(p,p)));
    l = min (l ,(length(p)-1.) / dr);
  }
  return l;    
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de196.png" alt="fractal_de196", height=200px></td>
</tr>


<tr><td><code>marvelousbilly<code></td>
<td><pre> 
mat3 rotmat(float angle, vec3 axis){
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;
	return mat3(oc * axis.x * axis.x + c,  oc * axis.x * axis.y - axis.z * s,
	  oc * axis.z * axis.x + axis.y * s,  oc * axis.x * axis.y + axis.z * s,  
	  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 
	  oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  
	  oc * axis.z * axis.z + c);
}
float de(vec3 p){    
    mat3 r = rotmat(3.14159, vec3(0.,1.,0.)); //rotation matrix
    float scale= 2.;
    int Iterations = 10;
    int i;
    vec3 C = vec3(1.,5.4,10.+10.*sin(0.5));
    for(i = 0; i < Iterations; i++){ 
        p = r * (p);
        float x = p.x; float y = p.y; float z = p.z; float x1 = x; float y1 = y;
        x=abs(x);y = abs(y);
        if(x-y<0.){x1=y;y=x;x=x1;}
        if(x-z<0.){x1=z;z=x;x=x1;}
        if(y-z<0.){y1=z;z=y;y=y1;}

        z-=0.5*C.z*(scale-1.)/scale;
        z=-abs(-z);
        z+=0.5*C.z*(scale-1.)/scale;
        
        p = vec3(x,y,z);
        r = rotmat(31.4159/4.+5.60,vec3(1.,0.5,0.6));
        p = r * (p);
        x = p.x; y = p.y; z = p.z;
        
        x=scale*x-C.y*(scale-1.);
        y=scale*y-C.y*(scale-1.);
        z=scale*z;

        p = vec3(x,y,z);
    }
    return (length(p) - 2.) * pow(scale,float(-i)); 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de197.png" alt="fractal_de197", height=200px></td>
</tr>



<tr><td><code>adapted from code by marvelousbilly<code></td>
<td><pre> 
float de(vec3 p){    
    mat3 r = rotate3D(3.14159, vec3(0.,1.,0.));
    float scale= 2.;
    int Iterations = 10;
    int i;
    vec3 C = vec3(1.,5.4,10.+10.*sin(0.5));
    for(i = 0; i < Iterations; i++){ 
        p = r * (p);
        float x = p.x; float y = p.y; float z = p.z; float x1 = x; float y1 = y;

        x=abs(x);y = abs(y);
        if(x-y<0.){x1=y;y=x;x=x1;}
        if(x-z<0.){x1=z;z=x;x=x1;}
        if(y-z<0.){y1=z;z=y;y=y1;}

        z-=0.5*C.z*(scale-1.)/scale;
        z=-abs(-z);
        z+=0.5*C.z*(scale-1.)/scale;
        
        p = vec3(x,y,z);
        r = rotate3D(31.4159/4.+5.60,vec3(1.,0.5,0.6));
        p = r * (p);
        x = p.x; y = p.y; z = p.z;
        
        x=scale*x-C.y*(scale-1.);
        y=scale*y-C.y*(scale-1.);
        z=scale*z;

        p = vec3(x,y,z);
    }
    return (length(p) - 2.) * pow(scale,float(-i)); 
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de198.png" alt="fractal_de198", height=200px></td>
</tr>


<tr><td><code>nameless<code></td>
<td><pre> 
float de(vec3 p0){
  vec4 p = vec4(p0, 1.);
  p.xyz=abs(p.xyz);
  if(p.x > p.z)p.xz = p.zx;
  if(p.z < p.y)p.zy = p.yz;
  if(p.y > p.x)p.yx = p.xy;
  for(int i = 0; i < 8; i++){
    if(p.x > p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y > p.x)p.yx = p.xy;
    p.xyz = abs(p.xyz);
    p*=(2.15/clamp(dot(p.xyz,p.xyz),.4,1.));
    p.xyz-=vec3(0.3,0.2,1.6);
  }
  float m = 1.5;
  p.xyz-=clamp(p.xyz,-m,m);
  return length(p.xyz)/p.w;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de199.png" alt="fractal_de199", height=200px></td>
</tr>



<tr><td><code>evilryu<code></td>
<td><pre> 
void ry(inout vec3 p, float a){  
    float c,s;vec3 q=p;  
    c = cos(a); s = sin(a);  
    p.x = c * q.x + s * q.z;  
    p.z = -s * q.x + c * q.z; 
}  
float plane(vec3 p, float y) {
    return length(vec3(p.x, y, p.z) - p);
}
float menger_spone(in vec3 z0){
    z0=z0.yzx;
    vec4 z=vec4(z0,1.0);
    vec3 offset =0.83*normalize(vec3(3.4,2., .2));
    float scale = 2.;
    for (int n = 0; n < 8; n++) {
        z = abs(z);
        ry(z.xyz, 1.5);
        if (z.x < z.y)z.xy = z.yx;
        if (z.x < z.z)z.xz = z.zx;
        if (z.y < z.z)z.yz = z.zy;
        ry(z.xyz, -1.21);
        z = z*scale;
        z.xyz -= offset*(scale-1.0);
    }
    return (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.01)/z.w;
}
float de(vec3 p){ 
    float d1 = plane(p, -0.5);
    float d2 = menger_spone(p+vec3(0.,-0.1,0.));
    float d = d1;
    vec3 res = vec3(d1, 0., 0.);
    if(d > d2){
        d = d2;
        res = vec3(d2, 1., 0.0);
    }
    return res.x;
} 
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de200.png" alt="fractal_de200", height=200px></td>
</tr>







</table>
<br>



<a id="composed"></a><h2>Composed Shapes</h2>
<p>&nbsp; This section is home to more complex expressions of geometry, showing some different methods of composition. I have put them here if there is more than one or two support functions. Folds and operators are broken out, and may be easier to understand.</p>



<table style="width:100%">
  <tr>
    <th>Author</th>
    <th>Code</th> 
    <th>Example</th>
  </tr>
  <tr>
<tr><td><code>gaziya5 aka gaz<code></td>   
<td><pre> 
#define sabs(a) sqrt(a * a + 0.005)
#define smin(a,b) SMin1(a,b,0.0003)
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float SMin1(float a, float b, float k){
  return a + 0.5 * ((b-a) - sqrt((b-a) * (b-a) + k));
}
vec2 fold(vec2 p, int n){
  p.x=sabs(p.x);
  vec2 v=vec2(0,1);
  for(int i=0;i < n;i++){
    p-=2.0*smin(0.0,dot(p,v))*v;
    v=normalize(vec2(v.x-1.0,v.y));
  }
  return p;    
}
float sdTorus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float de(vec3 p){
  float A=5.566;
  float c=7.0;
  p=mod(p,c)-c*0.5;
  p.xz=fold(p.xz,5);
  for(int i=0;i<5;i++){
    p.xy=abs(p.xy)-2.0;
    p.yz=abs(p.yz)-2.5;
    p.xy*=rot(A);
    p.yz*=rot(A*0.5);
    p=abs(p)-2.0;
  }
  vec2 s=vec2(0.05,0.02);
  float h=0.08;
  float de=1.0;
  vec3 q=p;
  q.xy=fold(q.xy,5);
  q.y-=2.;
  q.x-=clamp(q.x,-h,h);
  de=min(de,sdTorus(q,s));
  q=p;
  q.xy*=rot(M_PI/exp2(5.0));
  q.xy=fold(q.xy,5);
  q.y-=2.0;
  q.x-=clamp(q.x,-h,h);
  de=min(de,sdTorus(q.xzy,s));
  return de;
}</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de39.png" alt="fractal_de39", height=200px></td>
  </tr>
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec4 sphere (vec4 z) {
  float r2 = dot (z.xyz, z.xyz);
  if (r2 < 2.0)
    z *= (1.0 / r2);
  else z *= 0.5;
  return z;
}
vec3 box (vec3 z) {
  return clamp (z, -1.0, 1.0) * 2.0 - z;
}
float DE0 (vec3 pos) {
  vec3 from = vec3 (0.0);
  vec3 z = pos - from;
  float r = dot (pos - from, pos - from) * pow (length (z), 2.0);
  return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;
}
float DE2 (vec3 pos) {
  vec3 params = vec3 (0.5, 0.5, 0.5);
  vec4 scale = vec4 (-20.0 * 0.272321);
  vec4 p = vec4 (pos, 1.0), p0 = p;
  vec4 c = vec4 (params, 0.5) - 0.5; // param = 0..1

  for (float i = 0.0; i < 10.0; i++) {
    p.xyz = box(p.xyz);
    p = sphere(p);
    p = p * scale + c;
  }
  return length(p.xyz) / p.w;
}
float de (vec3 pos) {
  return max (DE0(pos), DE2(pos));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de59.png" alt="fractal_de59", height=200px></td>
</tr>


<tr><td><code>jorge2017a1<code></td>    
<td><pre> 
float de2(vec3 p) {
  vec3 op = p;
  p = abs(1.0 - mod(p, 2.));
  float r = 0., power = 8., dr = 1.;
  vec3 z = p;
  for (int i = 0; i < 7; i++) {
    op = -1.0 + 2.0 * fract(0.5 * op + 0.5);
    float r2 = dot(op, op);
    r = length(z);
    if (r > 1.616) break;
    float theta = acos(z.z / r);
    float phi = atan(z.y, z.x);
    dr = pow(r, power - 1.) * power * dr + 1.;
    float zr = pow(r, power);
    theta = theta * power;
    phi = phi * power;
    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
    z += p;
  }
  return (.5 * log(r) * r / dr);
}

float de1(vec3 p) {
  float s = 1.;
  float d = 0.;
  vec3 r,q;
  r = p;
  q = r;
  for (int j = 0; j < 6; j++) {
    r = abs(mod(q * s + 1.5, 2.) - 1.);	
    r = max(r, r.yzx);
    d = max(d, (.3 - length(r *0.985) * .3) / s);
    s *= 2.1;
  }
  return d;
}
float de(vec3 p) {
  return min(de1(p), de2(p));
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de60.png" alt="fractal_de60", height=200px></td>
</tr>
  
  
<tr><td><code>mrange<code></td>    
<td><pre>
void sphere_fold(inout vec3 z, inout float dz) {
const float fixed_radius2 = 1.9;
const float min_radius2   = 0.5;
    float r2 = dot(z, z);
    if(r2 < min_radius2) {
        float temp = (fixed_radius2 / min_radius2);
        z *= temp;
        dz *= temp;
    } else if(r2 < fixed_radius2) {
        float temp = (fixed_radius2 / r2);
        z *= temp;
        dz *= temp;
    }
}
vec3 pmin(vec3 a, vec3 b, vec3 k) {
  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);
  return mix(b, a, h) - k*h*(1.0-h);
}
void box_fold(float k, inout vec3 z, inout float dz) {
  // soft clamp after suggestion from ollij
  const vec3  folding_limit = vec3(1.0);
  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));
  z = zz * 2.0 - z;
}
float sphere(vec3 p, float t) {
  return length(p)-t;
}
float torus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float de(vec3 z) {
    const float scale = -2.8;
    vec3 offset = z;
    float dr = 1.0;
    float fd = 0.0;
    const float k = 0.05;
    for(int n = 0; n < 5; ++n) {
        box_fold(k/dr, z, dr);
        sphere_fold(z, dr);
        z = scale * z + offset;
        dr = dr * abs(scale) + 1.0;        
        float r1 = sphere(z, 5.0);
        float r2 = torus(z, vec2(8.0, 1));        
        float r = n < 4 ? r2 : r1;        
        float dd = r / abs(dr);
        if (n < 3 || dd < fd) {
          fd = dd;
        }
    }
    return fd;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de62.png" alt="fractal_de62", height=200px></td>
</tr>
  
  
<tr><td><code>evilryu<code></td>    
<td><pre>
void sphere_fold(inout vec3 z, inout float dz) {
  float fixed_radius2 = 1.9;
  float min_radius2 = 0.1;
  float r2 = dot(z, z);
  if(r2 < min_radius2) {
    float temp = (fixed_radius2 / min_radius2);
    z *= temp; dz *= temp;
  }else if(r2 < fixed_radius2) {
    float temp = (fixed_radius2 / r2);
    z *= temp; dz *= temp;
  }
}
void box_fold(inout vec3 z, inout float dz) {
  float folding_limit = 1.0;
  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;
}
float de(vec3 z) {
  vec3 offset = z;
  float scale = -2.8;
  float dr = 1.0;
  for(int n = 0; n < 15; ++n) {
    box_fold(z, dr);
    sphere_fold(z, dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;
  }
  float r = length(z);
  return r / abs(dr);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de64.png" alt="fractal_de64", height=200px></td>
</tr>
  
  



<tr><td><code>mrange<code></td>    
<td><pre>
vec3 mod3(inout vec3 p, vec3 size) {
  vec3 c = floor((p + size*0.5)/size);
  p = mod(p + size*0.5, size) - size*0.5;
  return c;
}
void sphere_fold(float fr, inout vec3 z, inout float dz) {
const float fixed_radius2 = 4.5;
const float min_radius2   = 0.5;
  float r2 = dot(z, z);
  if(r2 < min_radius2) {
    float temp = (fr / min_radius2);
    z *= temp;
    dz *= temp;
  } else if(r2 < fr) {
    float temp = (fr / r2);
    z *= temp;
    dz *= temp;
  }
}
void box_fold(float fl, inout vec3 z, inout float dz) {
  z = clamp(z, -fl, fl) * 2.0 - z;
}
float sphere(vec3 p, float t) {
  return length(p)-t;
}
float torus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float mb(float fl, float fr, vec3 z) {
  vec3 offset = z;
  const float scale = -3.0;
  float dr = 1.0;
  float fd = 0.0;
  for(int n = 0; n < 5; ++n) {
    box_fold65(fl, z, dr);
    sphere_fold65(fr, z, dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;        
    float r1 = sphere65(z, 5.0);
    float r2 = torus65(z, vec2(8.0, 1));        
    float r = n < 4 ? r2 : r1;        
    float dd = r / abs(dr);
    if (n < 3 || dd < fd) {
      fd = dd;
    }
  }
  return fd;
}
#define PATHA 0.4*vec2(0.11, 0.21)
#define PATHB 0.7*vec2(13.0, 3.0)
float de(vec3 p) { 
  float tm = p.z;
  const float folding_limit = 2.3;
  const vec3  rep = vec3(10.0);
  
  vec3 wrap = vec3(sin(tm*PATHA)*PATHB, tm);
  vec3 wrapDeriv = normalize(vec3(PATHA*PATHB*cos(PATHA*tm), 1.0));
  p.xy -= wrap.xy;
  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);

  p -= rep*vec3(0.5, 0.0, 0.0);
  p.y *= (1.0 + 0.1*abs(p.y));
  vec3 i = mod3(p, rep);
  
  const float fixed_radius2 = 4.5;
  float fl = folding_limit + 0.3*sin(0.025*p.z+1.0)- 0.3; 
  float fr = fixed_radius2 - 3.0*cos(0.025*sqrt(0.5)*p.z-1.0);

  return mb(fl, fr, p);
} 
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de65.png" alt="fractal_de65", height=200px></td>
</tr>
  
  
  
<tr><td><code>WAHa_06x36<code></td>    
<td><pre>
float periodic(float x,float period,float dutycycle){
  x/=period;
  x=abs(x-floor(x)-0.5)-dutycycle*0.5;
  return x*period;
}
float de(vec3 pos){
  vec3 gridpos=pos-floor(pos)-0.5;
  float r=length(pos.xy);
  float a=atan(pos.y,pos.x);
  a+=12.*0.3*sin(floor(r/3.0)+1.0)*sin(floor(pos.z)*13.73);
  return min(max(max(
  periodic(r,3.0,0.2),
  periodic(pos.z,1.0,0.7+0.3*cos(4.))),
  periodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(4.))),0.25);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de67.png" alt="fractal_de67", height=200px></td>
</tr>
  
  



  
<tr><td><code>dr2<code></td>    
<td><pre>
vec2 Rot2D (vec2 q, float a)
{
  vec2 cs;
  cs = sin (a + vec2 (0.5 * M_PI, 0.));
  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));
}
float PrBoxDf (vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}
float de(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.y = mod (p.y - 4. * a + 2., 4.) - 2.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, 2. * M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de68.png" alt="fractal_de68", height=200px></td>
</tr>
 
  
<tr><td><code>dr2<code></td>    
<td><pre>
vec2 Rot2D(vec2 q, float a)
{
  vec2 cs;
  cs = sin (a + vec2 (0.5 * M_PI, 0.));
  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));
}
float PrBoxDf(vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}
float de(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de69.png" alt="fractal_de69", height=200px></td>
</tr>




<tr><td><code>Kali<code></td>    
<td><pre>
mat2 rot(float a) {
    return mat2(cos(a),sin(a),-sin(a),cos(a));	
}
vec4 formula(vec4 p) {
    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;
    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);
    p.xy*=rot(.5);
    return p;
}
float screen(vec3 p) {
    float d1=length(p.yz-vec2(.25,0.))-.5;	
    float d2=length(p.yz-vec2(.25,2.))-.5;	
    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));
}
float de(vec3 pos) {
    vec3 tpos=pos;
    tpos.z=abs(2.-mod(tpos.z,4.));
    vec4 p=vec4(tpos,1.5);
    float y=max(0.,.35-abs(pos.y-3.35))/.35;

    for (int i=0; i<8; i++) {p=formula(p);}
    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);

    float sc=screen(tpos);
    return min(sc,fr);	
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de70.png" alt="fractal_de70", height=200px></td>
</tr>




<tr><td><code>glkt<code></td>    
<td><pre>
float smin( float a, float b, float k ){
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);
}
float noise(vec3 p){
    vec3 np = normalize(p);
    
    float a = 0.1*snoise2D(np.xy*10.);
    float b = 0.1*snoise2D(0.77+np.yz*10.);
    
    a = mix(a,.5,abs(np.x));
    b = mix(b,.5,abs(np.z));
    return mix(a+b-.4,.5,abs(np.y)/2.);
}
float de(vec3 p){
    float d = (-1.*length(p)+3.)+1.5*noise71(p);    
    d = min(d, (length(p)-1.5)+1.5*noise71(p) );  
    float m = 1.5; float s = .03;    
    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          
    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    
    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    
    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    
    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );
    return d;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de71.png" alt="fractal_de71", height=200px></td>
</tr>

<tr><td><code>unconed<code></td>    
<td><pre>
vec4 fold1(vec4 z) {
    vec3 p = z.xyz;
    p = p - 2.0 * clamp(p, -1.0, 1.0);
    return vec4(p, z.w);
}
vec4 fold2(vec4 z) {
    vec3 p = z.xyz;
    p = p - 2.0 * clamp(p, -1.0, 1.0);
    return vec4(p * 2.0, 2.0 * z.w);
}
vec4 invertRadius(vec4 z, float radius2, float limit) {
  float r2 = dot(z.xyz, z.xyz);
  float f = clamp(radius2 / r2, 1., limit);
  return z * f;
}
vec4 affine(vec4 z, float factor, vec3 offset) {
  z.xyz *= factor;
  z.xyz += offset;
  z.w *= abs(factor);
  return z;
}
vec4 mandel(vec4 z, vec3 offset) {
  float x = z.x;
  float y = z.y;
  z.w = 2. * length(z.xy) * z.w + 1.;
  z.x = x*x - y*y + offset.x;
  z.y = 2.*x*y + offset.y;
  return z;
}
vec4 invert(vec4 z, float factor) {
  float r2 = dot(z.xyz, z.xyz);
  float f = factor / r2;
  return z * f;
}
vec4 rotateXY(vec4 z, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2 m = mat2(c, s, -s, c);
  return vec4(m * z.xy, z.zw);
}
vec4 rotateXZ(vec4 z, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2 m = mat2(c, s, -s, c);
  vec2 r = m * z.xz;
  return vec4(r.x, z.y, r.y, z.w);
}
vec4 shiftXY(vec4 z, float angle, float radius) {
  float c = cos(angle);
  float s = sin(angle);
  return vec4(vec2(c, s) * radius + z.xy, z.zw);
}
float de(vec3 p) {
    vec4 z = vec4(p, 1.0);
    float t = 344. * .2; // change this number for different shapes
    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * 1.1;
    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * 1.1;
    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * 1.1;

    z = invertRadius_73(z, 10.0, 1.5);
    z = invertRadius_73(z, 10.0*10.0, 2.0);
    z = rotateXY(z, t);
    z = fold1(z);
    z = rotateXZ(z, t * 1.112);
    z.xyz += vo3;
    z = fold2(z);
    z.xyz += vo1;
    z = affine(z, -1.5, p);
    z = invertRadius(z, 4.0*4.0, 2.0);
    z = affine(z, -1.5, p);
    z = rotateXY(z, t * .881);
    z = fold1(z);
    z = rotateXZ(z, t * .783);
    z = fold1(z);
    z = affine_73(z, -1.5, p);
    z = invertRadius(z, 10.0*10.0, 3.0);
    z = fold1(z);
    z = fold1(z);
    z = affine(z, -1.5, p);
    z = invertRadius(z, 10.0*10.0, 2.0);

    vec3 po = vec3(0.0, 0.0, 0.0);
    vec3 box = abs(z.xyz);
    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;
    float d2 = (max(box.x - 20.0, max(box.y - .5, box.z - .5))) / z.w;
    float d3 = min(d1, d2);
    return d3;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de73.png" alt="fractal_de73", height=200px></td>
</tr>




<tr><td><code>lewiz<code></td>    
<td><pre>
void sphereFold(inout vec3 z, inout float dz){
  float r2 = dot(z,z);
  if (r2 < 0.5){ 
    float temp = 2.0;
    z *= temp;
    dz*= temp;
  }else if (r2 < 1.0){ 
    float temp = 1.0 / r2;
    z *= temp; dz*= temp;
  }
}
void boxFold(inout vec3 z, inout float dz){
  z = clamp(z, -1.0, 1.0) * 2.0 - z;
}
float de(vec3 z){
  float scale = 2.0;
  vec3 offset = z;
  float dr = 1.0;
  for (int n = 0; n < 10; n++){
    boxFold(z,dr);
    sphereFold(z,dr);
    z = scale * z + offset;
    dr = dr * abs(scale) + 1.0;
  }
  float r = length(z);
  return r / abs(dr);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de74.png" alt="fractal_de74", height=200px></td>
</tr>
  
  
  
<tr><td><code>raziel<code></td>    
<td><pre>
float op_u(float d1, float d2){
	return (d1 < d2) ? d1 : d2;
}
void sphere_fold(inout vec3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv){
    float r_sq = dot(p, p);
    if (r_sq < m_rad_sq){
        float t = f_rad_sq * m_rad_sq_inv;
        p *= t;
        dr *= t;
    }
    else if (r_sq < f_rad_sq){
        float t = f_rad_sq / r_sq;
        p *= t;
        dr *= t;
    }
}
void box_fold(inout vec3 p, float fold_limit){
    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;
}
// estimators return (dist, mat_id, custom_value)
float estimator_mandelbox(vec3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit){
    vec3 off = p;
    float dr = 1.0;
    float mrs_inv = 1.0 / m_rad_sq;
    for (int i = 0; i < 10; ++i){
        box_fold(p, fold_limit);
        sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);

        p = scale * p + off;
        dr = dr * abs(scale) + 1.0;
        vec3 ot = p - vec3(0.5);
    }
    return length(p) / abs(dr);
}
vec3 mod_pos(vec3 p, float a, float b){
    p.zx = mod(p.zx, a) - b;  
    return p;
}
float de(vec3 p){
    vec3 p_mb = mod_pos_77(p, 4.4, 2.2);
    float res_mb = estimator_mandelbox(p, -2.5, 0.1, 2.5, 1.0);
    vec3 p_pl = p;
    p_pl.y += 4.0;
    p_pl = mod_pos(p_pl, 2.0, 1.0);
    float res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0);

    return op_u(res_mb, res_pl);
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de77.png" alt="fractal_de77", height=200px></td>
</tr>
  
  
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
#define opRepEven(p,s) mod(p,s)-0.5*s 
#define opRepOdd(p,s) p-s*round(p/s)
#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
float lpNorm_83(vec3 p, float n){
	p = pow(abs(p), vec3(n));
	return pow(p.x+p.y+p.z, 1.0/n);
}
vec2 pSFold_83(vec2 p,float n){
    float h=floor(log2(n)),a =6.2831*exp2(h)/n;
    for(float i=0.0; i < h+2.0; i++){
	 	vec2 v = vec2(-cos(a),sin(a));
		float g= dot(p,v);
 		p-= (g - sqrt(g * g + 5e-3))*v;
 		a*=0.5;
    }
    return p;
}
vec2 sFold45_83(vec2 p, float k){
    vec2 v = vec2(-1,1)*0.7071;
    float g= dot(p,v);
 	return p-(g-sqrt(g*g+k))*v;
}
float frameBox_83(vec3 p, vec3 s, float r){   
    p = abs(p)-s;
    p.yz=sFold45_83(p.yz, 1e-3);
    p.xy=sFold45_83(p.xy, 1e-3);
    p.x = max(0.0,p.x);
	return lpNorm_83(p,5.0)-r;
}
float sdRoundBox_83( vec3 p, vec3 b, float r ){   
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}
float deObj_83(vec3 p){   
    return min(sdRoundBox_83(p,vec3(0.3),0.05),frameBox_83(p,vec3(0.8),0.1));
}
float de(vec3 p){
    float de=1.0;
    // p.z-=iTime*1.1;
    vec3 q= p;
    p.xy=pSFold_83(-p.xy,3.0);
    p.y-=8.5;
    p.xz=opRepEven(p.xz,8.5);
    float de1=length(p.yz)-1.;
    de=min(de,de1);
    p.xz=pSFold_83(p.xz,8.0);
    p.z-=2.0;
    float rate=0.5;
    float s=1.0;
    for(int i=0;i<3;i++){
        p.xy=abs(p.xy)-.8;
        p.xz=abs(p.xz)-0.5;
        p.xy*=rot(0.2);
        p.xz*=rot(-0.9);
        s*=rate;
        p*=rate;
        de=min(de,deObj_83(p/s));
    }
    q.z=opRepOdd(q.z,8.5);
    float de0=length(q)-1.5;
    de=min(de,de0);
    return de;    
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de83.png" alt="fractal_de83", height=200px></td>
</tr>
  
  
  
<tr><td><code>gaziya5 aka gaz<code></td>    
<td><pre> 
vec3 rot(vec3 p,vec3 a,float t){
	a=normalize(a);
	vec3 v = cross(a,p),u = cross(v,a);
	return u * cos(t) + v * sin(t) + a * dot(p, a);   
}
float lpNorm(vec2 p, float n){
	p = pow(abs(p), vec2(n));
	return pow(p.x+p.y, 1.0/n);
}
float sdTorus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}
float smin( float a, float b, float k ) {
    float h = clamp(.5+.5*(b-a)/k, 0., 1.);
    return mix(b, a, h) - k*h*(1.-h);
}
float deTetra(vec3 p){
	vec2 g=vec2(-1,1)*0.577;
	return pow(
		pow(max(0.0,dot(p,g.xxx)),8.0)
		+pow(max(0.0,dot(p,g.xyy)),8.0)
		+pow(max(0.0,dot(p,g.yxy)),8.0)
		+pow(max(0.0,dot(p,g.yyx)),8.0),
		0.125);
}
float deStella(vec3 p){
    p=rot(p,vec3(1,2,3),time*3.0);
	return smin(deTetra_85(p)-1.0,deTetra(-p)-1.0,0.05);
}
#define Circle 2.2
vec2 hash2( vec2 p ){
    p = mod(p, Circle*2.0); 
	return fract(sin(vec2(
        dot(p,vec2(127.1,311.7)),
        dot(p,vec2(269.5,183.3))
    ))*43758.5453);
}
vec3 voronoi(vec2 x){
    x*=Circle;
    vec2 n = floor(x);
    vec2 f = fract(x);
	vec2 mg, mr;
    float md = 8.0;
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ ){
        vec2 g = vec2(float(i),float(j));
		vec2 o = hash2( n + g );
		o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );
        vec2 r = g + o - f;
        float d = dot(r,r);
        if( d < md ){
            md = d;
            mr = r;
            mg = g;
        }
    }
    md = 8.0;
    for( int j=-2; j <= 2; j++ )
    for( int i=-2; i <= 2; i++ ){
        vec2 g = mg + vec2(float(i),float(j));
		vec2 o = hash2( n + g );
		o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );
        vec2 r = g + o - f;
        if( dot(mr-r,mr-r)>0.00001 )
        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );
    }
    return vec3( md, mr );
}
float voronoiTorus(vec3 p){
    vec2 size = vec2(12,5);
    vec2 q = vec2(length(p.xz) - size.x, p.y);
	vec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;
	vec3 vr=voronoi(uv*vec2(20,8));
    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));
	return lpNorm(p2,5.0)-0.1; 
}
float fractal(vec3 p)
{   
    vec3 offset = vec3(6,0,0);
    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));
    vec3 co = vec3(cos(time),0,sin(time))*10.0;
    float s1= abs(sin(time))*3.0+2.0;
    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;
    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));
    de=min(de,deS);    
    return de;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de85.png" alt="fractal_de85", height=200px></td>
</tr>
  
  
  
  
  
  
<tr><td><code>iq<code></td>    
<td><pre> 
float maxcomp(in vec3 p ){ 
	return max(p.x,max(p.y,p.z));
}

float sdBox( vec3 p, vec3 b ){
  vec3  di = abs(p) - b;
  float mc = maxcomp(abs(p)-b);
  return min(mc,length(max(di,0.0)));
}

float de(vec3 p){
    vec3 w = p; vec3 q = p;
    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;
    float d = sdBox(q,vec3(1.0));
    float s = 1.0;
    for( int m=0; m<7; m++ ){
        float h = float(m)/6.0;
        p =  q.yzx - 0.5*sin( 1.5*p.x + 6.0 + p.y*3.0 + float(m)*5.0 + vec3(1.0,0.0,0.0));
        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;
        d = max( c, d );
   }
   return d*0.5;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de132.png" alt="fractal_de132", height=200px></td>
</tr>
  
<tr><td><code>adapted from code by sdfgeoff<code></td>
<td><pre> 
float sdRoundBox( vec3 p, vec3 b, float r ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float df(vec3 co) {
    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);
    co = mod(co, vec3(1.0)) - 0.5;
    return sdRoundBox(co, vec3(rad, rad, 0.3), 0.1);
}

float de(vec3 p){
    float body = 999.0;
    float scale = 0.2;
    vec3 co = p;
    mat4 m = mat4(
		vec4(0.6373087, -0.0796581,  0.7664804, 0.0),
  		vec4(0.2670984,  0.9558195, -0.1227499, 0.0),
  		vec4(-0.7228389,  0.2829553,  0.6304286, 0.0),
        vec4(0.1, 0.6, 0.2, 0.0));
    for (int i=0; i<3; i++) {
        co = (m * vec4(co, float(i))).xyz;
        scale *= (3.0);   
        float field = df(co * scale) / scale;
        body = smin_op(body, field, 0.05);
    }
    return -body;
}
</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de189.png" alt="fractal_de189", height=200px></td>
</tr>



<tr><td><code>plento<code></td>
<td><pre> 
float sdBox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

vec2 rotate(vec2 k,float t){
  return vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);
}

float de(vec3 pos){
    vec3 b = vec3(0.9 , 4.5, 0.70);
    float p = sin(pos.z * 0.1) * 2.0;
  
    pos = vec3(rotate(pos.xy, p), pos.z);
    pos.y += 1.2;
    pos = mod(pos, b) -0.5 * b;
    pos.x *= sin(length(pos * 1.8) * 2.0) * 1.4;
    
    return sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(0.4));
}

</pre></td>
<td class="fitwidth"><img src="images/DEC/fractal_de201.png" alt="fractal_de201", height=200px></td>
</tr>
  
</table>
<br>



<a id="licensing"></a><h2>Licensing</h2>
<p>
&nbsp; I am releasing this resource under the <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode"> CC Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>. This is the default Shadertoy license unless otherwise specified by the shader author, the same license provided with the hg_sdf header, and which seems similarly appropriate for this resource. There are some utility functions which are provided by the <a href="../resources/noise.glsl">Twigl noise header</a>, available under the MIT license, and the <a href="../resources/hg_sdf.glsl">hg_sdf header</a>.
</p>

<p>
&nbsp; I have gathered these distance estimator functions from several sources (hg_sdf, Shadertoy, and code deobfuscated from the #つぶやきGLSL tag on Twitter). I have done my best to give credit to the authors, but I do not have a complete record - if you have information to that end, please contact me via email. If you are doing something cool with them, or would like to contribute to this resource, please contact me at jb239812@ohio.edu.
</p>

</div>
<br>
<p>Last updated 5/27/2021</p>
</body>
</html>
